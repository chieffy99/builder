<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cmapping System vNext - Experimental Prototype v1.0</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-workspace: #010206;
            --bg-card: rgba(22, 27, 34, 0.85);
            --text-primary: #e0e0e0;
            --border-light: rgba(107, 138, 253, 0.3);
            --accent-primary: #6b8afd;
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            --card-glow-active: 0 0 15px rgba(107, 138, 253, 0.4);
            --z-base: 100;
            --z-top-gap: 5000;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        #workspace {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: var(--bg-workspace);
            overflow: auto;
            padding: 1rem;
        }

        /* CARD STYLING */
        .card {
            position: absolute;
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            min-width: 250px;
            min-height: 150px;
            box-shadow: var(--card-shadow);
            cursor: grab;
            user-select: none;
            transition: box-shadow .2s, border-color .2s;
            overflow: hidden; /* Important for containing content */
        }
        
        .card.active {
            border-color: var(--accent-primary);
            box-shadow: var(--card-shadow), var(--card-glow-active);
        }
        
        .card:active {
            cursor: grabbing;
        }
        
        .card-header {
            padding: 10px 15px;
            background: rgba(33, 38, 45, 0.7);
            cursor: move;
            font-weight: 600;
            font-size: 14px;
        }

        .card-body {
            padding: 15px;
            height: calc(100% - 40px); /* Adjust based on header height */
            overflow: auto;
        }

        .card-body .summary-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            text-align: center;
            margin-top: 20%;
        }

        /* RESIZE HANDLES */
        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 50%;
            z-index: 2;
            opacity: 0;
            transition: opacity .2s;
        }

        .card.active .resize-handle {
            opacity: 1;
            border-color: rgba(107, 138, 253, 0.4);
        }
        
        .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
        .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }
        .resize-handle.n { top: -8px; left: calc(50% - 8px); cursor: ns-resize; }
        .resize-handle.s { bottom: -8px; left: calc(50% - 8px); cursor: ns-resize; }
        .resize-handle.w { left: -8px; top: calc(50% - 8px); cursor: ew-resize; }
        .resize-handle.e { right: -8px; top: calc(50% - 8px); cursor: ew-resize; }

        /* FAB (FLOATING ACTION BUTTON) */
        #fab {
            position: fixed;
            right: 1.5rem;
            bottom: 1.5rem;
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--accent-primary), #9c5fff);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            z-index: 99999;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #fab:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 6px 25px rgba(107, 138, 253, 0.4);
        }

        #fab svg {
            fill: #fff;
            width: 28px;
            height: 28px;
        }
        
        /* RADIAL MENU (triggered by FAB) */
        #radial-menu {
            position: fixed;
            right: 1.5rem;
            bottom: 1.5rem;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 99998;
        }

        #radial-menu.active {
            transform: scale(3.5); /* Adjust scale for menu size */
            pointer-events: auto;
        }
        
        .radial-item {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #21262d;
            border: 1px solid var(--border-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.5);
        }
        
        #radial-menu.active .radial-item {
            opacity: 1;
            transform: scale(1);
        }
        
        /* STACK OVERLAY */
        #stackOverlay {
            position: absolute;
            display: none;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--accent-primary);
            background: rgba(107, 138, 253, 0.1);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border-radius: 12px;
            padding: .5rem;
            box-sizing: border-box;
            z-index: calc(var(--z-base) + var(--z-top-gap) + 1);
            pointer-events: none;
        }

        .overlay-content {
            max-width: 100%;
            max-height: 100%;
            overflow: auto;
            text-align: center;
            padding: 1rem;
        }
        
        .overlay-content button {
            background-color: var(--accent-primary);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            margin: 5px;
            font-weight: 600;
        }
        
        .overlay-content button.btn-cancel {
            background-color: #333;
        }

        /* Toast for notifications */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-120%);
            background: rgba(33, 38, 45, 0.9);
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 15px;
            pointer-events: none;
            opacity: 0;
            transition: all .3s ease-in-out;
            z-index: 100000;
        }
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body>

<div id="workspace"></div>

<div id="radial-menu">
    <!-- Radial items will be added here by JS -->
</div>

<button id="fab" title="Add Card">
    <svg viewBox="0 0 24 24"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/></svg>
</button>

<div id="stackOverlay"><div class="overlay-content"></div></div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const workspace = document.getElementById('workspace');
    const fab = document.getElementById('fab');
    const radialMenu = document.getElementById('radial-menu');
    const stackOverlay = document.getElementById('stackOverlay');
    const overlayContent = stackOverlay.querySelector('.overlay-content');

    let cardIdCounter = 0;
    let zIndexCounter = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--z-base')) || 100;
    
    let activeCard = null;
    let stackingState = {
        isStacking: false,
        sourceCard: null
    };

    // --- Card Types for Radial Menu ---
    const cardTypes = [
        { type: 'summary', icon: '‚àë', title: 'Summary Card' },
        { type: 'line', icon: 'üìà', title: 'Line Chart' },
        { type: 'bar', icon: 'üìä', title: 'Bar Chart' },
        { type: 'pie', icon: 'ü•ß', title: 'Pie Chart' },
        { type: 'table', icon: 'üìã', title: 'Table' },
    ];

    // --- Event Listeners ---
    fab.addEventListener('click', toggleRadialMenu);
    document.addEventListener('click', (e) => {
        if (!fab.contains(e.target) && !radialMenu.contains(e.target)) {
            if (radialMenu.classList.contains('active')) {
                toggleRadialMenu();
            }
        }
    });

    // --- Main Functions ---

    function createCard(type, x, y) {
        const card = document.createElement('div');
        card.className = 'card';
        card.id = `card-${++cardIdCounter}`;
        
        // Random initial position if not specified
        const posX = x !== undefined ? x : 100 + Math.random() * (workspace.clientWidth - 400);
        const posY = y !== undefined ? y : 100 + Math.random() * (workspace.clientHeight - 400);
        
        card.style.left = `${posX}px`;
        card.style.top = `${posY}px`;
        
        let headerText = 'Card';
        let bodyContent = '';

        switch (type) {
            case 'summary':
                headerText = '‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
                bodyContent = `<div class="summary-value">45,872.50 ‡∏ø</div>`;
                card.style.width = '250px';
                card.style.height = '150px';
                break;
            case 'line':
            case 'bar':
            case 'pie':
                headerText = type === 'line' ? '‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏™‡πâ‡∏ô' : (type === 'bar' ? '‡∏Å‡∏£‡∏≤‡∏ü‡πÅ‡∏ó‡πà‡∏á' : '‡∏Å‡∏£‡∏≤‡∏ü‡∏ß‡∏á‡∏Å‡∏•‡∏°');
                bodyContent = `<canvas id="chart-${card.id}"></canvas>`;
                card.style.width = '450px';
                card.style.height = '350px';
                break;
            case 'table':
                headerText = '‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
                bodyContent = `<p style="text-align:center; margin-top:20%;">Table Content</p>`;
                card.style.width = '400px';
                card.style.height = '250px';
                break;
        }

        card.innerHTML = `<div class="card-header">${headerText}</div><div class="card-body">${bodyContent}</div>`;
        
        workspace.appendChild(card);
        
        if (type.includes('chart')) {
            renderChart(card, type);
        }

        addInteractions(card);
        addResizeHandles(card);
        bringToFront(card);
    }

    function addInteractions(card) {
        let offsetX, offsetY;
        
        const dragStart = (e) => {
            if (e.target.classList.contains('resize-handle')) return;
            bringToFront(card);
            card.style.cursor = 'grabbing';
            offsetX = e.clientX - card.offsetLeft;
            offsetY = e.clientY - card.offsetTop;

            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dragEnd);
        };

        const dragMove = (e) => {
            card.style.left = `${e.clientX - offsetX}px`;
            card.style.top = `${e.clientY - offsetY}px`;
        };

        const dragEnd = () => {
            card.style.cursor = 'grab';
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', dragEnd);
        };
        
        card.addEventListener('mousedown', dragStart);
        card.addEventListener('dblclick', handleDoubleClick);
    }
    
    function handleDoubleClick(e) {
        const card = e.currentTarget;
        if (!stackingState.isStacking) {
            // Start stacking process
            stackingState.isStacking = true;
            stackingState.sourceCard = card;
            card.style.borderColor = '#ff6b6b'; // Highlight source card
            showToast('Stacking Mode: Double-click on a target card to mix.', 3000);
        } else {
            // This is the target card
            if (card === stackingState.sourceCard) {
                // User double-clicked the same card, cancel stacking
                cancelStacking();
                return;
            }
            stackingState.targetCard = card;
            showStackOverlay(stackingState.targetCard);
        }
    }
    
    function cancelStacking() {
        if(stackingState.sourceCard) {
            stackingState.sourceCard.style.borderColor = '';
        }
        stackingState = { isStacking: false, sourceCard: null, targetCard: null };
        showToast('Stacking cancelled.', 2000);
    }
    
    function showStackOverlay(targetCard) {
        const rect = targetCard.getBoundingClientRect();
        const wsRect = workspace.getBoundingClientRect();
        stackOverlay.style.width = rect.width + 'px';
        stackOverlay.style.height = rect.height + 'px';
        stackOverlay.style.left = rect.left - wsRect.left + workspace.scrollLeft + 'px';
        stackOverlay.style.top = rect.top - wsRect.top + workspace.scrollTop + 'px';

        overlayContent.innerHTML = `
            <p>Mix "${stackingState.sourceCard.querySelector('.card-header').textContent}" with "${targetCard.querySelector('.card-header').textContent}"?</p>
            <button class="btn-ok">‡∏ú‡∏™‡∏° (Mix)</button>
            <button class="btn-cancel">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å (Cancel)</button>
        `;
        stackOverlay.style.display = 'flex';
        bringToFront(targetCard);

        stackOverlay.querySelector('.btn-ok').onclick = executeStack;
        stackOverlay.querySelector('.btn-cancel').onclick = hideStackOverlay;
    }

    function executeStack() {
        const { sourceCard, targetCard } = stackingState;
        if (!sourceCard || !targetCard) return;

        // Simple visual stacking: move source card relative to target
        targetCard.querySelector('.card-body').appendChild(sourceCard);
        sourceCard.style.position = 'absolute';
        sourceCard.style.left = '20px';
        sourceCard.style.top = '50px';
        sourceCard.style.transform = 'scale(0.8)';
        
        showToast('Cards mixed!', 2000);
        hideStackOverlay();
    }

    function hideStackOverlay() {
        stackOverlay.style.display = 'none';
        cancelStacking();
    }

    function addResizeHandles(card) {
        ['nw', 'ne', 'sw', 'se', 'n', 's', 'w', 'e'].forEach(dir => {
            const handle = document.createElement('div');
            handle.className = 'resize-handle ' + dir;
            card.appendChild(handle);
            handle.addEventListener('mousedown', e => startResize(e, card, dir));
        });
    }

    function startResize(e, card, direction) {
        e.stopPropagation();
        bringToFront(card);
        
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = card.offsetWidth;
        const startHeight = card.offsetHeight;
        const startLeft = card.offsetLeft;
        const startTop = card.offsetTop;

        function doResize(e) {
            let newWidth = startWidth;
            let newHeight = startHeight;
            let newLeft = startLeft;
            let newTop = startTop;

            if (direction.includes('e')) {
                newWidth = startWidth + (e.clientX - startX);
            }
            if (direction.includes('w')) {
                newWidth = startWidth - (e.clientX - startX);
                newLeft = startLeft + (e.clientX - startX);
            }
            if (direction.includes('s')) {
                newHeight = startHeight + (e.clientY - startY);
            }
            if (direction.includes('n')) {
                newHeight = startHeight - (e.clientY - startY);
                newTop = startTop + (e.clientY - startY);
            }

            // Aspect Ratio Lock (Shift key for free transform)
            if (!e.shiftKey) {
                if (direction.includes('n') || direction.includes('s')) {
                    newWidth = newHeight * (startWidth / startHeight);
                } else {
                    newHeight = newWidth / (startWidth / startHeight);
                }
            }

            card.style.width = `${Math.max(200, newWidth)}px`;
            card.style.height = `${Math.max(150, newHeight)}px`;
            card.style.left = `${newLeft}px`;
            card.style.top = `${newTop}px`;
            
            // Re-render chart if it exists
            const chartCanvas = card.querySelector('canvas');
            if(chartCanvas) {
                const chartId = chartCanvas.id.split('-')[1];
                const cardType = chartId.startsWith('card') ? card.querySelector('.card-header').textContent.toLowerCase().includes('‡πÄ‡∏™‡πâ‡∏ô') ? 'line' : (card.querySelector('.card-header').textContent.toLowerCase().includes('‡πÅ‡∏ó‡πà‡∏á') ? 'bar' : 'pie') : null;
                if(cardType) {
                    renderChart(card, cardType);
                }
            }
        }

        function stopResize() {
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
        }

        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
    }
    
    function bringToFront(card) {
        const allCards = [...workspace.querySelectorAll('.card')];
        allCards.forEach(c => c.classList.remove('active'));

        zIndexCounter++;
        card.style.zIndex = zIndexCounter;
        card.classList.add('active');
        activeCard = card;
        
        // Normalize other card z-indexes to prevent huge numbers
        const baseZ = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--z-base')) || 100;
        if (zIndexCounter > baseZ + allCards.length) {
            const sortedCards = allCards.sort((a, b) => parseInt(a.style.zIndex) - parseInt(b.style.zIndex));
            sortedCards.forEach((c, index) => {
                c.style.zIndex = baseZ + index;
            });
            zIndexCounter = baseZ + allCards.length;
            card.style.zIndex = zIndexCounter;
        }
    }

    function toggleRadialMenu() {
        const isActive = radialMenu.classList.toggle('active');
        if (isActive) {
            fab.innerHTML = `<svg viewBox="0 0 24 24"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/></svg>`; // Close icon
            populateRadialMenu();
        } else {
            fab.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/></svg>`; // Plus icon
            radialMenu.innerHTML = '';
        }
    }

    function populateRadialMenu() {
        radialMenu.innerHTML = ''; // Clear old items
        const angleStep = 360 / cardTypes.length;
        cardTypes.forEach((item, i) => {
            const angle = angleStep * i - 90; // Start from top
            const button = document.createElement('button');
            button.className = 'radial-item';
            button.innerHTML = item.icon;
            button.title = item.title;
            button.style.transform = `rotate(${angle}deg) translate(120%) rotate(${-angle}deg) scale(0)`;
            button.dataset.type = item.type;
            
            button.addEventListener('click', () => {
                createCard(item.type);
                toggleRadialMenu();
            });

            radialMenu.appendChild(button);
            
            // Staggered animation
            setTimeout(() => {
                button.style.transform = `rotate(${angle}deg) translate(120%) rotate(${-angle}deg) scale(1)`;
            }, i * 50);
        });
    }

    function showToast(message, duration = 2500) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('show'));
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }
    
    function renderChart(card, type) {
        const canvasId = card.querySelector('canvas').id;
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Destroy existing chart instance if it exists
        if(Chart.getChart(canvasId)) {
            Chart.getChart(canvasId).destroy();
        }
        
        let chartData, chartOptions;

        if (type === 'line' || type === 'bar') {
            chartData = {
                labels: ['‡∏°.‡∏Ñ.', '‡∏Å.‡∏û.', '‡∏°‡∏µ.‡∏Ñ.', '‡πÄ‡∏°.‡∏¢.', '‡∏û.‡∏Ñ.', '‡∏°‡∏¥.‡∏¢.'],
                datasets: [{
                    label: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á',
                    data: [12, 19, 3, 5, 2, 3].map(v => v * Math.random() * 1000 + 5000),
                    borderColor: type === 'line' ? '#6b8afd' : 'rgba(107, 138, 253, 0.7)',
                    backgroundColor: 'rgba(107, 138, 253, 0.2)',
                    borderWidth: 2,
                    fill: type === 'line' ? true : false,
                    tension: 0.4
                }]
            };
            chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true, ticks: { color: 'white' } },
                    x: { ticks: { color: 'white' } }
                },
                plugins: { legend: { display: false } }
            };
        } else if (type === 'pie') {
            chartData = {
                labels: ['‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó A', '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó B', '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó C', '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó D'],
                datasets: [{
                    data: [300, 50, 100, 80].map(v => v * Math.random() + 50),
                    backgroundColor: ['#6b8afd', '#9c5fff', '#56ab2f', '#fdcb6e']
                }]
            };
            chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { labels: { color: 'white' } } }
            };
        }
        
        new Chart(ctx, { type: type, data: chartData, options: chartOptions });
    }
    
    // Create an initial summary card
    createCard('summary', 50, 50);

});
</script>
</body>
</html>