
สิ่งที่ฉันกรองมันออกมา
Concept
"total_slots": 7/24,
"reasoning": "Data handing",
"AI & Humans_friendly": true
"row_scanning": "2 Eye & my Old",
"cognitive_load": "Predivtive Desinge"


เรามาดูการอ้างอิง Ontology เดิมทีโครงสร้างของฉัน มันยืดหยุ่นกว่า Ontology มาก ดังนั้นไม่ต้องห่วงในการขยาย แต่จะเอา Onto มาเป็นโครงร่างคลุมด้านนอก 
ฉันจะไม่ใช้ ภาษาใน ontology เพื่อ map กับฟีลด์ แต่ฉันจะเอาโครงสร้าง sting ของฉัน map ก่อน เพื่อแทรกกฏของตัวเองลงไป 

เอาเป็นว่า กฏบางอย่างในไฟล์มันใช้ไม่ได้ ระบบของฉันส่วนใหญ่คือ 
- ตัวจำแนก ได้แก่ headder หรือ ค่าในฟีลด์ ซึ่งโดยทั่วไปแล้วจะมีความสำคัญเรียงจากซ้ายไปขวาอยู่แล้ว (ตามหลักภาษา) คือ Date, (ID1,ID2), (StatN,StatC), [SlotN]
- ฟีลด์/ข้อมูล โดยปกติแล้ว สามารถใส่ลงไปใน  ID1, ID2, Slot ได้ แต่จะมีหน้าที่บทบาทต่างกัน 
ฉันเองใช้มาตั้งนานแต่ไม่เคยได้อธิบายเป็นกรอบแบบนี้ออกมา เลยไม่มีกฏการทำงานทีชัดเจนเขียนไว้ ทีนี้เราจะพบว่าแต่ละชุดของค่าเหล่านี้มีความสัมพันธ์ที่แยกจากกัน 
แต่เมื่อรวมกันจะกลายเป็นฤติกรรมที่กระทำออกมาเปลี่ยนแปลงไป และสามารถคำนวนหรืออธิบายได้ทั้ง fact (ของคณิต) และ truth (ของภาษา) 

(StatN, StatC) บอกผลลัพธ์หรือสถานะของ Event 
โดยปกติแล้วจะเป็นการ transfrom หรือควบคุม และช่วยเพิ่มการจำแนก เช่น การเปลี่ยน A B C จะทำให้สามารพสร้างการแปลี่ยนแปลงค่าใน slot ตามฐานข้อมูลที่ header ของ slot นั้นมีอยู่ 
ในกรณีนี้ B คือปริมาณ C คือราคาสินค้า เมื่อนำามคำนวนกัน จะได้ A ที่เป็นราคาของรายการใน transection น้น 
การแปลง Stat ไม่ได้แปลงทุกตัวใน row ด้วยวิธีเดียวกัน แต่ Stat เป็นเหมือนรหัส บรรจุ logic ที่ส่งผลต่อ field ของ slot 
ใน transection ที่ฉันใช้ฉันจะใส่ slot 2 อันหลังเป็นกฏ dreduce และ deduce โดยไม่ถุกเปลี่ยนตาม Stat ที่ใช้บางตัว 
ทำให้สามารถแทนที่ event จำนวนมากในธุรกรรมทางการค้าได้ หรือจะเรียกได้ว่า stat คือการ เปลี่ยน label เพื่อแสดงความสัมพันธ์ของ slot ใน row นั้น 
ดังนั้นการออกแบบฟีลด์ต่างๆใน slot เป็นสิ่งสำคัญ ต้องคำนึงถึงเหตุการณ์ที่จะเกิดขึ้น กลายมาเป็นความแตกต่างใน slot ที่มี stat เป็นตัวเลือกก็ว่าได้
 
ดังตัวอย่างเช่น ข้อมูลดังนี้ (เริ่มฟีลด์แรกที่ statN)
0,B,0,2,3,4,0,0,0 = ลูกค้าซื้อเงินสด
0,B,0,2,3,4,0,20,0 = ลูกค้าซื้อเงินสด และมีส่วนลด 20
0,B,0,2,3,4,0,0,500 = ลูกค้าซื้อเงินสด และจ่ายเงินชำระหนี้ (หรือมีเหตุใดๆที่ร้านเพิ่มกับสถานะผูกพันหนี้สินของลูกค้าลดลง หรือการเพิ่มค่าเงินสดสะสมของลูกค้า (เช่นลูกค้าลืมเงินทอน ระบบนี้สุจริตพอที่จะนึกถึงไว้ก่อน)

1,B,0,2,3,4,0,0,0 = ลูกค้าซือเงินเชื่อ 
1,B,0,2,3,4,0,20,0 = ลูกค้าซื้อเงินเชื่อ และมีส่วนลด 20 
1,B,0,2,3,4,0,0,500 = ลูกค้าซื้อของแบบเงินเชื่อ และชำระเงินสดส่วนนึง (หรือชำระหนี้เก่า)

0,B,0,0,0,0,0,0,0 = ไม่มีอะไรเกิดขึ้นในรายการ
0,B,0,0,0,0,0,20,0 = ระบบอาจมีส่วนลด 20 ที่เกิดจากเวลา (เช่นวันเกิด) เมื่ออยู่ในสถานะนี้ สามารถเป็นโบนัสะแนนแทน 
0,B,0,0,0,0,0,0,500 = ลูกค้าชำระหนี้อย่างเดียว

1,B,0,0,0,0,0,0,0 = บางทีอาจจะ error แต่การที่ค่าเป็น 0 จึงไม่มีผลต่อธุรกรรมใดๆ แต่ควรกำหนดขอบเขตเหตุการณ์ไว้ 
1,B,0,0,0,0,0,20,0 =เออ คิดเผื่อไว้ก่อนแต่ที่แน่ๆ อะไรที่เกี่ยวกับหนี้แล้วลูกค้าได้รับประโยชน์ก็ต้องมีหละน่า
1,B,0,0,0,0,0,0,500 =  แบบข้อช้างบน

มันมีความหมายทั้งนั้น นี่ยังไมรวมการใส่ invert ( - ) ที่ตัวเลขนะ  และมีมากกว่านี้ ถ้าจะทำ
และสิ่งสำคัญคือ ฉันจะให้ความสำคัญกับความเป็นไปได้ของเหตุการณ์ ไม่ใช่เกิดเหตุการณ์แต่ไม่สามารถบันทึกได้ 


ระบบ transection ฉันจะไม่มีการ compu มาเก็บข้อมูลในตัว ดังตัวอย่าง สมมุติว่า จะคำนวนราคาของ sting
1,B,0,2,3,4,0,20,500

สมมุติว่าสินค้าแตละ slot เท่ากับ และใช้ C ที่เป็นรหัสอ้างอิงราคา (หรือ การเป็นข้อมููลพื้นฐานสินค้า)
slot1 = 10
slot2 = 15
slot3 = 20
slot4 = 25
slot5 = 30

1,B,0,2,3,4,0,20,500 = B จำสินค้าใน slot ที่1 2 3 4และ 5 ยังไม่เป็นราคา 
1,C,10,15,20,25,30,20,500 = การเปลี่ยน C สามารถแสดงถึงการสร้าง sting ใหม่เป็น Input ราคาสินค้า ใน transection ได้ และยังตรวจจสอบได้ในตัวเอง
1,A,0,30,60,50,0,20,500 = B*C แปลว่า ลูกค้าซือเงินเชื่อ 140 บาท ได้รับส่วนลด 20 บาท ชำระหนี้ 500 บาท เงินสดร้านรับเท่ากับ 140-20+500 = 620 บาท สถานะหนี้ลูกค้า +120-500 = ลดลง 380 บาท

และแทนที่ว่าฉันจะต้องมาเก็บ จำนวนสินค้า และราคาขาย  ฉันสร้าง  logic ที่สัมพันธ์กัน ทำให้เกิดการแปลงค่า และเก็บแค่ transection ของ B กับ ฐานข้อมูลคือ  C  (ไม่ต้อง เก็บ A เพราะมี logic compu ให้)


Core
Event: Narative/Sting
Word: Rule/Data dictionary
Logic: Reasoning/Formula
Space: Dimensions/Position/Slot
Time: Rotten/Date
Gravity: Relation/ID
Transform: Shift/Stat


Formula
เงินสด =Sumifs(SlotI,Relation+Dimentioms+Time+Logic,N=0)
เงินเชื่อ =Sumifs(SlotI,Relation+Dimentioms+Time+Logic,N=1)

เห็นได้ว่า event มันเกิดตั้งแต่การกำหนด slot แต่จัดประเภทด้วย stat แล้วระบุตัวตนของ ID ที่เรียงลำดับด้วย SeQ (Date)
สร้างความสัมพันธ์ด้วยสูตร excel แค่ sumif ออกมาแล้วเอาไปใช้ต่อที่ไหนก็ได้เลยตามตวามสัมพันธ์ของข้อมูลที่อิง

StatN/StatC Logic:
StatN=0: รายการเงินสด
StatN=1: รายการซื้อเชื่อ
StatC=A: ผลของคำนวน (B×C pattern)
StatC=B: จำนวนนับ
StatC=C: ราคาขาย


  "rules": [
    {
      "code": { "StatN": 0},
      "type": "Reasoning","Default"
      "name": "เงินสด",
      "usesSlots": ["Slot1",....,"Slot-3"], 
      "produces": ["Slot1",....,"Slot-3"],
      "expression": "์Clash",
      "description": "รายการเงินสด"
     },
    {
      "code": { "StatN": 1},
      "type": "Reasoning",
      "name": "เงินเชื่อ",
      "usesSlots": ["Slot1",....,"Slot-3"], 
      "produces": ["Slot1",....,"Slot-3"],
      "expression": "์Deb",
      "description": "รายการซื้อเชื่อ"
     },
    {
      "code": { "StatC": A},
      "type": "Logic",
      "name": "ราคารวม",
      "usesSlots": ["Slot1",....,"Slot-3"], 
      "produces": ["Slot1",....,"Slot-3"],
      "expression": "comput",
      "description": "ผลของสินค้าที่ถูกคำนวนชอง {"StatC":B,SlotN}*{"StatC":C,SlotN}"
     },
    {
      "code": { "StatC": B},
      "type": "Reasoning",
      "name": "จำนวนนับ" ,
      "usesSlots": ["Slot1",....,"Slot-3"], 
      "produces": ["Slot1",....,"Slot-3"],
      "expression": "์amont",
      "description": "จำนวนนับ"
     },
    {
      "code": { "StatC": C},
      "type": "Reasoning",
      "name": "ราคาขาย",
      "usesSlots": ["Slot1",....,"Slot-3"], 
      "produces": ["Slot1",....,"Slot-3"],
      "expression": "์database",
      "description": "ราคาขาขของสินค้า"
     },
    {
      "code": { "Slot-2"},
      "type": "Position",
      "name": "Reduce",
      "usesSlots": ["Slot-2"], 
      "produces": ["Slot-2"],
      "expression": "์Obligation",
      "description": "สิทธิผูกพันลูกค้าที่ไม่ใช่เงินสด"
     },
    {
      "code": { "Slot-1"},
      "type": "Position",
      "name": "Deduce",
      "usesSlots": ["Slot-1"], 
      "produces": ["Slot-1"],
      "expression": "์Obligation",
      "description": "สิทธิผูกพันลูกค้าที่เป็นเงินสด"
     },
   
