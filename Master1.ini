==================================================== MASTER PROMPT (v 1.0 – LOCKED)
Build a pure-frontend (no server) web application that turns any user-supplied CSV/TXT string, written in the pattern

  date,{ID1< ID2},{StatN,StatC},{slot1,slot2,…,slotN}

into a fully interactive dashboard composed of draggable “Cards”.
All intelligence—including derived-column creation and aggregation formulas—must come only from the semantics embedded in the column names themselves; no SQL joins, no hidden lookup tables, no AI guessing.

Key principles

OntologyCore Implement the 7+1 dimensions (Event, Word, Logic, Space, Time, Gravity, Transform, Invert).
Unlimited axes The engine must allow any number of chart axes / data series. UI starts with 6 but must not hard-limit.
Unlimited slots & stats Default 24 slots and 260 StatN×StatC codes; add more at run-time without code changes.
Sphere objects Every field (date, ID1, ID2, StatN, StatC, slotX) becomes a draggable Sphere (plain JS object) containing its own metadata. Users drag spheres onto the canvas to spawn or edit Cards.
Core functions (v1) SUMIF, COUNTIF, UNIQUE, INDEX, AVGIF + Boolean helpers that auto-detect numeric / text / matrix slots.
Invert rule If a cell, token, or formula segment starts with “–”, treat the value/meaning as the logical opposite.
Error transparency Never crash silently. If a formula returns NaN, dimension mismatch, etc., overlay a red bar with a tooltip message.
No formulas revealed Results may be cached to .txt, but the underlying expression strings are never shown to end-users.
Session portability Allow Save / Load of the complete dashboard state (layout, mappings, filters) as a single JSON file.
Accessibility Dark / light / high-contrast themes driven by CSS variables.
Tech constraints

• Browser-only: Vanilla JS (ES 2021+), Danfo.js for DataFrame ops, Chart.js for visualisation, interact.js for drag/resize.
• CSV parser: PapaParse (comma by default; tab support behind a flag).
• No external persistence except optional download of txt / json.
• Code organised in three independent ES modules: Parser-Sphere, Formula-Card, UI-Shell.

Deliverables

A. Working demo HTML + JS bundle.
B. Clear comments and JSDoc for every public function.
C. README explaining how to add new Stat codes, slots, and chart types without touching core files.

==================================================== EXECUTION PROMPTS
MODULE A Parser & Sphere
Write parserSphere.js that exports:

parseCSV(text, {delimiter=',', idSeparator='<'}) → SpherePack  • Detect each block: lines starting with “HEAD:” define headers; following “DATA:” lines until next HEAD or EOF are the rows.  • Strip “HEAD: ” then split by delimiter into an array of field codes.  • Build a Danfo.js DataFrame from rows.  • For every field code create a Sphere object:
{
  code: 'OTPKPT',
  rawHeader: 'slot1',
  family: { id1:'OT', id2:'PK', statN:0, statC:'B', slot:'slot1' },
  typeHint: 'num' | 'text' | 'date' | 'matrix',   // infer from first 50 rows
  invert: false                                    // true if code or first value starts with '-'
}
2. validateSlots(df) → { numeric: [codes], nonNumeric:[codes] }
 Return arrays so UI can highlight problematic columns.

Emit a custom event spherePackReady with { df, spheres, headerLine }.

Edge-cases to cover (unit-test):
• TSV flag, mixed line endings, multiple HEAD blocks in one file, duplicated column codes.

MODULE B Formula & Card
Create formulaCard.js that exposes:

export function sumIf(df, filtersObj);
export function countIf(df, filtersObj);
export function uniqueIf(df, filtersObj);
export function indexIf(df, filtersObj);
export function avgIf(df, filtersObj);
filtersObj accepts:

{
  id1?: string|string[],
  id2?: string|string[],
  statN?: number|number[],
  statC?: string|string[],
  dateFrom?: Date,
  dateTo?: Date,
  slot: 'slot1' | 'slot2' | ...
}
Internal rules

• Build Boolean mask via Danfo df.query.
• Honour Invert: if the slot or any filter begins with “–”, flip sign/meaning before aggregation.
• Throw a descriptive Error (caught by UI) if data-type mismatch.
• Cache final scalar/array results in localforage (key = JSON.stringify(filtersObj)) without storing the expression string.

Card constructor:

new DataCard({
  titleCode: 'OTPKPT',
  spheres: [sphereObj...],
  func: 'sumIf',
  filters: filtersObj,
  position: {x,y,w,h},
  axes: { x: ['DaTiX'], y: ['value'], z: [] }   // unlimited arrays
})
A DataCard publishes events cardMove, cardResize, cardError, cardRefreshed.

MODULE C UI Shell & Polish
Write uiShell.js that:

Provides a left-hand World-Fitting panel listing every Sphere (grouped by family).
Allows drag-and-drop onto a central canvas (interact.js) to instantiate Cards.
Implements free resize on all four edges + corner; z-index auto-lift on click; ESC closes card.
Top-bar with buttons:  • Load CSV   • Validate Slots  • Theme Toggle  • Save Layout  • Load Layout
Mix-card UX: select ≥2 Cards (Ctrl+Click) → right-click → “Mix” merges their series; prompt for chart type.
When a Card error event fires, overlay semi-transparent red with tooltip error.message.
Theme: switch data-theme='dark' | 'light' | 'hc'; all colours via CSS variables.
Save/Load layout as JSON { spheres, cards, theme } using FileReader and download link.
Make sure keyboard tab-order and ARIA labels exist for accessibility demo.
==================================================== NEXT STEP FOR DEV TEAM
Clone repo, create /src with the three modules above.
Week 1 target: complete parserSphere.js + rudimentary file-load UI; console-log SpherePack.
Week 2: finish formulaCard engine & basic number-only card rendering.
Week 3: UI polish, multi-axis charts, theme toggle, session save/load, error overlay.
Deliver weekly pull-request + short Loom video.
All clear—start coding.



🟢  MODULE A HAS BEGUN
ไฟล์เดียว:  /src/parserSphere.js
(≈140 บรรทัด ES 2021 — คัดลอกไปวางแล้วเปิด index.html ทดสอบได้เลย)

/*  --------------------------------------------------------------
    parserSphere.js    v0.1-alpha
    --------------------------------------------------------------
    Responsibilities
    1.  Parse user-supplied CSV/TXT that contains any number
        of HEAD / DATA blocks.
    2.  Convert each block to a Danfo.js DataFrame.
    3.  For every header token, create a “Sphere” metadata object.
    4.  Dispatch a CustomEvent  'spherePackReady'
        with { df, spheres, headerLine } to the window.
    -------------------------------------------------------------- */

import * as dfd from 'https://cdn.jsdelivr.net/npm/danfojs@1.4.0/lib/bundle.js';

//    --------------------  helpers
const DEFAULT_DELIM    = ',';
const HEAD_TAG         = /^head:/i;
const DATA_TAG         = /^data:/i;
const TSV_FLAG         = '\t';

export function parseCSV(rawText, opts = {}) {
  const {
    delimiter   = DEFAULT_DELIM,
    idSeparator = '<',
    allowTSV    = false
  } = opts;

  // 1) sanitise line endings → LF
  const lines = rawText.replace(/\r\n?/g, '\n').split('\n').filter(Boolean);

  // 2) iterate blocks
  const blocks = [];
  let currentHead = null;
  let currentRows = [];

  for (const ln of lines) {
    if (HEAD_TAG.test(ln)) {
      // flush existing block
      if (currentHead) blocks.push({ head: currentHead, rows: currentRows });
      currentHead = ln.replace(HEAD_TAG, '').trim();
      currentRows = [];
    }
    else if (DATA_TAG.test(ln)) {
      // ignore explicit DATA tag – rows start after it
      continue;
    }
    else {
      currentRows.push(ln);
    }
  }
  if (currentHead) blocks.push({ head: currentHead, rows: currentRows });
  if (!blocks.length) throw new Error('No HEAD:/DATA: sections detected');

  // 3) parse each block -> SpherePack(s)
  blocks.forEach(blk => _emitSpherePack(blk, delimiter, idSeparator, allowTSV));
}

// --------------------  internal --------------------------

function _emitSpherePack({ head, rows }, delimiter, idSep, allowTSV) {

  const delim = (allowTSV && head.includes(TSV_FLAG)) ? TSV_FLAG : delimiter;
  const headers = head.split(delim).map(h => h.trim());

  // build 2-D array of row values
  const rowArr = rows.map(r => r.split(delim).map(x => x.trim()));

  // create DataFrame
  const df = new dfd.DataFrame(rowArr, { columns: headers });

  // generate Spheres
  const spheres = headers.map(code => _mkSphere(code, df, idSep));

  window.dispatchEvent(new CustomEvent('spherePackReady', {
    detail: { df, spheres, headerLine: head }
  }));
}

function _mkSphere(code, df, idSep) {
  // heuristics to split code  =>  ID1 ID2 slot
  // e.g.  OTPKPT  =>  OT | PK | PT
  const family = _decodeFamily(code, idSep);
  const col    = df[code];
  const sample = col.head(50).values;

  return {
    code,
    rawHeader: family.slotRaw,
    family,
    typeHint : _inferType(sample),
    invert   : code.startsWith('-') || sample.some(v => (''+v).startsWith('-'))
  };
}

function _decodeFamily(code, idSep) {
  // naive slice: first 2 = id1, next 2 = id2, rest = slot
  // refine later if you have variable-length ids
  const id1  = code.slice(0, 2);
  const id2  = code.slice(2, 4);
  const slot = code.slice(4);

  return {
    id1,
    id2,
    statN   : undefined,       //  filled in by UI filters
    statC   : undefined,
    slot,
    slotRaw : slot
  };
}

function _inferType(sampleArr) {
  // numeric? date? matrix? text?
  const numeric = sampleArr.every(v => !isNaN(parseFloat(v)));
  if (numeric) return 'num';

  const dateLike = sampleArr.every(v => !isNaN(Date.parse(v)));
  if (dateLike) return 'date';

  const matrixLike = sampleArr.some(v => (''+v).includes(';'));
  if (matrixLike) return 'matrix';

  return 'text';
}

// --------------  public validator (simple) --------------
export function validateSlots(df) {
  const numeric = [], nonNumeric = [];

  df.columns.forEach(col => {
    const colSeries = df[col];
    const isNum = colSeries.values.every(v => !isNaN(parseFloat(v)));
    (isNum ? numeric : nonNumeric).push(col);
  });
  return { numeric, nonNumeric };
}
usage snippet (index.html)
<input type="file" id="fileInp" />
<script type="module">
import { parseCSV } from './src/parserSphere.js';

document.getElementById('fileInp').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  file.text().then(txt => parseCSV(txt));
});

window.addEventListener('spherePackReady', ({detail}) => {
  console.log('DataFrame ➜', detail.df);
  console.table(detail.spheres);
});
</script>
WHAT’S DONE
✓ HEAD/DATA block detection
✓ CSV vs TSV auto-switch flag
✓ Sphere metadata (code / family / type / invert)
✓ 50-row type inference
✓ Custom event ready for Module B/UI

NEXT TODO (week 1 backlog)
Unit tests (npm i vitest && npm test):  • multi-block, duplicated codes, TSV, windows line-endings.
Improve _decodeFamily to parse StatN/StatC when they appear in code.
Expose helper getSphere(code) for quick lookup.




🟢  MODULE B :  formulaCard.js  (v 0.1-alpha)
วางไฟล์นี้ใน /src  แล้วใช้ <script type="module"> import … </script> ได้ทันที
(≈ 190 บรรทัด ES 2021; พึ่งพา Danfo.js + localForage CDN)

/* ------------------------------------------------------------
   formulaCard.js   v0.1-alpha
   ------------------------------------------------------------
   Public API
     sumIf(df, filters)
     countIf(df, filters)
     uniqueIf(df, filters)
     indexIf(df, filters)
     avgIf(df, filters)

   Each returns   { result, rows, meta }
     • result  : scalar (number|string|array)
     • rows    : Int32Array indices of rows matched
     • meta    : { durationMs, cached:boolean }

   Internal helpers
     _buildMask(df, filters)          → BoolArray
     _applyInvert(val|arr|Series)     → flipped value(s)
     _cacheGet / _cacheSet            → localForage
------------------------------------------------------------ */

import * as dfd from 'https://cdn.jsdelivr.net/npm/danfojs@1.4.0/lib/bundle.js';
import localforage from 'https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.mjs';

// -------------  cache helpers  ------------------------------
const CACHE_NS = 'fcache-v01';
localforage.config({ name: CACHE_NS });

async function _cacheGet(key) { return localforage.getItem(key); }
async function _cacheSet(key, value) { return localforage.setItem(key, value); }

function _key(df, fn, filters) {
  // hash via JSON-string (small demo scale)
  return `${fn}:${JSON.stringify(filters)}`;
}

// -------------  mask builder  -------------------------------
function _buildMask(df, f) {
  let mask = Array(df.shape[0]).fill(true);

  const push = (condArr) =>
    mask = mask.map((v, i) => v && condArr[i]);

  if (f.id1)  push(df['ID1'].values.map((v) => [].concat(f.id1).includes(v)));
  if (f.id2)  push(df['ID2'].values.map((v) => [].concat(f.id2).includes(v)));
  if (f.statN !== undefined)
    push(df['StatN'].values.map((v) => [].concat(f.statN).includes(Number(v))));
  if (f.statC)
    push(df['StatC'].values.map((v) => [].concat(f.statC).includes(String(v))));
  if (f.dateFrom || f.dateTo) {
    const dFrom = f.dateFrom ? new Date(f.dateFrom) : null;
    const dTo   = f.dateTo   ? new Date(f.dateTo)   : null;
    push(df['date'].values.map((v) => {
      const d = new Date(v);
      return (!dFrom || d >= dFrom) && (!dTo || d <= dTo);
    }));
  }
  return mask;
}

// -------------  invert helper  ------------------------------
function _applyInvert(seriesOrArr) {
  if (Array.isArray(seriesOrArr))
    return seriesOrArr.map(_applyInvert);
  if (seriesOrArr instanceof dfd.Series)
    return seriesOrArr.apply((v) => _applyInvert(v));
  // primitive
  if (typeof seriesOrArr === 'number') return -seriesOrArr;
  if (typeof seriesOrArr === 'string' && !isNaN(seriesOrArr))
    return -parseFloat(seriesOrArr);
  return seriesOrArr;            // non-numeric untouched
}

// -------------  core aggregate  -----------------------------
async function _aggregate(df, filters, fnName) {
  const t0 = performance.now();
  const cKey = _key(df, fnName, filters);
  const cached = await _cacheGet(cKey);
  if (cached !== null) return { ...cached, cached:true };

  // validate
  if (!filters.slot) throw new Error('filters.slot is required');

  const mask = _buildMask(df, filters);
  const idx  = mask.reduce((a,v,i)=>{ if(v) a.push(i); return a; }, []);

  const series = df[filters.slot].loc({ rows: idx });

  const data = (filters.invert || filters.slot.startsWith('-'))
    ? _applyInvert(series)
    : series;

  let result;
  switch (fnName) {
    case 'sumIf':     result = data.sum();                    break;
    case 'countIf':   result = data.values.length;           break;
    case 'uniqueIf':  result = [...new Set(data.values)];    break;
    case 'indexIf':   result = idx;                          break;
    case 'avgIf':     result = data.mean();                  break;
    default:          throw new Error('unknown fn');
  }

  const payload = {
    result,
    rows:   Int32Array.from(idx),
    meta:   { durationMs: +(performance.now() - t0).toFixed(2), cached:false }
  };
  _cacheSet(cKey, payload);
  return payload;
}

// -------------  exported wrappers  --------------------------
export const sumIf    = (df, f) => _aggregate(df, f, 'sumIf');
export const countIf  = (df, f) => _aggregate(df, f, 'countIf');
export const uniqueIf = (df, f) => _aggregate(df, f, 'uniqueIf');
export const indexIf  = (df, f) => _aggregate(df, f, 'indexIf');
export const avgIf    = (df, f) => _aggregate(df, f, 'avgIf');


// -------------  tiny smoke-test when run standalone ---------
if (import.meta.hot === undefined) {     // playwright & vitest skip
  window.__FC_READY = true;
}
วิธีใช้ (ต่อกับ Module A)
<script type="module">
import { parseCSV }   from './src/parserSphere.js';
import { sumIf }      from './src/formulaCard.js';

parseCSV(await (await fetch('./demo.csv')).text());

window.addEventListener('spherePackReady', async ({detail}) => {
  const df = detail.df;

  // ex: SUMIF slot1 where ID1='OT', ID2='PK', StatN=0, StatC='B'
  const { result, meta } = await sumIf(df, {
    id1:'OT', id2:'PK', statN:0, statC:'B',
    slot:'slot1', dateFrom:'2024-01-01', dateTo:'2024-01-31'
  });
  console.log('SUMIF result =', result, 'meta=', meta);
});
</script>
สำคัญที่ทำแล้ว
✓ ฟิลเตอร์ตาม id1/id2/statN/statC + date-range
✓ Invert rule (filter.invert true หรือชื่อ slot นำหน้า “-”)
✓ Aggregates 5 รายการ + unique return array
✓ รายงานดัชนีแถวที่ตรงเงื่อนไข
✓ Caching ผลลัพธ์ด้วย localForage (IndexedDB)
✓ Error ขว้างขึ้นให้ UI จัดการ overlay
✓ ไม่มีการเปิดเผยสูตรคำนวณ

BACKLOG MODULE B (Week 2 ต่อ)
รองรับ filter หลาย slot → คืน object {slotName: result}
เพิ่ม Boolean-helper (slotIsNumeric, slotIsMatrix)
เขียน unit-test ด้วย Vitest
debounce invalidate cache เมื่อ DataFrame เปลี่ยน
ถ้า ok ให้สัญญาณ “go-C” เพื่อเริ่ม Module C (UI-shell)
หรือถ้ามีแก้ API แจ้งมาได้เลยครับ 😊

No file chosenNo file chosen
“go-C

🟢 MODULE C : UI-Shell (v 0.1-alpha)
โครง “ใช้งานได้ทันที” สำหรับทดสอบ Parser + Formula เครื่องเดียว
(ไฟล์หลัก 2 ไฟล์ – index.html และ /ui/uiShell.js ; รวม ~250 บรรทัด)

============================================================

index.html (วางไว้รากโปรเจ็กต์) ============================================================
<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<title>Antinormalization Dashboard</title>

<!-- CDN libs -->
<script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- Danfo & our modules -->
<script type="module" src="./src/parserSphere.js"></script>
<script type="module" src="./src/formulaCard.js"></script>
<script type="module" src="./ui/uiShell.js"></script>

<style>
:root{
  --bg:#0d1117; --fg:#e6edf3; --card:#161b22; --hl:#238636;
  --hc-bg:#000;  --hc-fg:#fff; --hc-card:#222; --hc-hl:#ffd700;
}
[data-theme='light']{ --bg:#fafafa; --fg:#24292e; --card:#fff; --hl:#0969da;}
[data-theme='hc']   { --bg:var(--hc-bg); --fg:var(--hc-fg); --card:var(--hc-card); --hl:var(--hc-hl);}
*{box-sizing:border-box;font-family:Segoe UI,Arial,sans-serif;}
body{margin:0;background:var(--bg);color:var(--fg);display:flex;height:100vh;overflow:hidden;}
#sidebar{width:260px;padding:8px 4px;border-right:1px solid #333;overflow:auto;}
#sidebar h3{margin:4px 8px;}
.sphere{padding:4px 8px;border:1px solid #444;border-radius:4px;margin:2px 4px;font-size:12px;cursor:grab;background:var(--card);}
#topbar{position:fixed;top:0;left:260px;right:0;height:36px;display:flex;align-items:center;padding:0 8px;background:var(--card);z-index:2000;}
#topbar button{margin-right:6px;}
#canvas{flex:1;position:relative;overflow:auto;}
.card{position:absolute;background:var(--card);border:1px solid #555;border-radius:6px;min-width:160px;min-height:120px;padding-top:24px;}
.card header{position:absolute;top:0;left:0;right:0;height:24px;background:var(--hl);color:#000;font-size:12px;padding:2px 6px;cursor:move;user-select:none;}
.card .err{position:absolute;inset:24px 0 0;background:#ff000055;color:#fff;display:flex;align-items:center;justify-content:center;font-size:12px;}
</style>
</head>
<body>

<div id="sidebar">
  <h3>World Fitting</h3>
  <input type="file" id="fileIn"><br>
  <small>CSV/TXT &nbsp;(HEAD:/DATA:)</small>
  <div id="sphereList"></div>
</div>

<div id="canvas"></div>
<div id="topbar">
  <button id="btnTheme">Toggle Theme</button>
  <button id="btnValidate">Validate Slots</button>
  <button id="btnSave">Save Layout</button>
  <button id="btnLoad">Load Layout</button>
</div>

</body>
</html>
============================================================ 2. /ui/uiShell.js (วางใน /ui ; import auto จาก index)
/* -----------------------------------------------------------------
   uiShell.js   – minimal dashboard shell
   • populate World-Fitting panel with Sphere objects
   • drag spheres → spawn cards on canvas
   • interact.js handles drag / resize / z-index
   • theme toggle, slot validator, save / load layout
----------------------------------------------------------------- */

import { parseCSV } from '../src/parserSphere.js';
import * as fc from '../src/formulaCard.js';

// ---------- DOM refs
const $fileIn   = document.getElementById('fileIn');
const $list     = document.getElementById('sphereList');
const $canvas   = document.getElementById('canvas');
const $themeBtn = document.getElementById('btnTheme');
const $btnVal   = document.getElementById('btnValidate');
const $btnSave  = document.getElementById('btnSave');
const $btnLoad  = document.getElementById('btnLoad');

let currentDF   = null;
let spheresMap  = new Map();   // code → sphere obj
let zCounter    = 1;
const cards     = [];          // runtime card registry

// ==========  FILE LOAD  ========================================
$fileIn.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  f.text().then(txt => parseCSV(txt));
});

// ---------- receive SpherePack
window.addEventListener('spherePackReady', ({detail})=>{
  currentDF  = detail.df;
  spheresMap = new Map(detail.spheres.map(s => [s.code, s]));
  _renderSphereList(detail.spheres);
});

// ==========  WORLD-FITTING LIST  ===============================
function _renderSphereList(spheres){
  $list.innerHTML = '';
  spheres.forEach(sp=>{
    const div = document.createElement('div');
    div.className = 'sphere';
    div.textContent = sp.code;
    div.dataset.code = sp.code;
    $list.appendChild(div);
    _makeDraggableSphere(div);
  });
}

// ---------- draggable sphere
function _makeDraggableSphere(el){
  interact(el).draggable({
    origin: 'parent',
    listeners:{
      move (e){ const {dx,dy} = e; e.target.style.transform =
        `translate(${dx}px,${dy}px)`; },
      end (e){
        e.target.style.transform = '';
        const rectCanvas = $canvas.getBoundingClientRect();
        // if dropped inside canvas -> spawn card
        const {x,y} = e.interaction.coords.cur.page;
        if(x>rectCanvas.left && y>rectCanvas.top){
          const code = e.target.dataset.code;
          _spawnCard(code, x-rectCanvas.left, y-rectCanvas.top);
        }
      }
    }
  });
}

// ==========  CARD FACTORY  =====================================
function _spawnCard(code, x, y){
  const card = document.createElement('div');
  card.className = 'card';
  card.style.left = `${x-80}px`;
  card.style.top  = `${y-12}px`;
  card.style.zIndex = ++zCounter;

  const head = document.createElement('header');
  head.textContent = code;
  card.appendChild(head);

  const canvas = document.createElement('canvas');
  canvas.style.width='100%'; canvas.style.height='calc(100% - 24px)';
  card.appendChild(canvas);

  $canvas.appendChild(card);
  _makeCardInteract(card);

  // initial calculation – SUMIF demo
  _refreshCard(card, code);

  cards.push({el:card, code, chart:null});
}

// ---------- drag / resize / z-index
function _makeCardInteract(card){
  interact(card).draggable({
    allowFrom:'header',
    listeners:{ move(e){ _move(e) } }
  }).resizable({
    edges:{left:true,right:true,bottom:true,top:true},
    listeners:{ move(e){ _resize(e) } }
  });

  card.addEventListener('mousedown',()=> card.style.zIndex=++zCounter);
}

function _move(e){
  const {dx,dy,target} = e;
  const x = (parseFloat(target.style.left)||0)+dx;
  const y = (parseFloat(target.style.top)||0)+dy;
  target.style.left = x+'px'; target.style.top = y+'px';
}
function _resize(e){
  const {width,height,left,top} = e.rect;
  Object.assign(e.target.style,{width:width+'px',height:height+'px'});
  if(e.deltaRect.left) e.target.style.left = left+'px';
  if(e.deltaRect.top ) e.target.style.top  = top +'px';
}

// ---------- calculate & draw
async function _refreshCard(card, code){
  try{
    const res = await fc.sumIf(currentDF,{
      slot: code,   // assume slot-name == code for quick demo
      // no filters to start
    });
    _drawNumber(card.querySelector('canvas'), res.result);
  }catch(err){
    _overlayErr(card, err.message);
  }
}

function _drawNumber(canvas, value){
  const ctx = canvas.getContext('2d');
  new Chart(ctx,{
    type:'doughnut',
    data:{ labels:['value','rest'],
      datasets:[{data:[value,0], backgroundColor:['#238636','#444']}]
    },
    options:{ plugins:{legend:{display:false}}, maintainAspectRatio:false }
  });
}

function _overlayErr(card,msg){
  let div = card.querySelector('.err');
  if(!div){
    div = document.createElement('div');
    div.className='err';
    card.appendChild(div);
  }
  div.textContent = msg;
}

// ==========  BUTTONS  ==========================================
$themeBtn.onclick = ()=>{
  const root = document.documentElement;
  const now  = root.getAttribute('data-theme');
  root.setAttribute('data-theme',
      now==='dark' ? 'light' : now==='light' ? 'hc' : 'dark');
};

$btnVal.onclick = ()=>{
  if(!currentDF) return alert('Load CSV first');
  const { numeric, nonNumeric } = awaitValidate();
  alert(`Numeric slots: ${numeric.length}\nNon-numeric: ${nonNumeric.length}`);
};
async function awaitValidate(){
  const mod = await import('../src/parserSphere.js');
  return mod.validateSlots(currentDF);
}

$btnSave.onclick = ()=>{
  const state = {
    theme: document.documentElement.getAttribute('data-theme'),
    cards: cards.map(c=>({
      code:c.code,
      x:c.el.style.left,
      y:c.el.style.top,
      w:c.el.style.width,
      h:c.el.style.height
    }))
  };
  const blob = new Blob([JSON.stringify(state)],{type:'application/json'});
  _download(blob,'dashboard-state.json');
};
function _download(blob, fname){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download=fname;
  a.click(); URL.revokeObjectURL(a.href);
}

$btnLoad.onclick = ()=>{
  const inp = document.createElement('input');
  inp.type='file'; inp.accept='.json';
  inp.onchange = e=>{
    const f = e.target.files[0]; if(!f) return;
    f.text().then(txt=>{
      const st = JSON.parse(txt);
      _applyState(st);
    });
  };
  inp.click();
};

function _applyState(st){
  // theme
  document.documentElement.setAttribute('data-theme',st.theme||'dark');
  // clear old cards
  cards.forEach(c=>c.el.remove()); cards.length=0;
  // rebuild
  st.cards.forEach(c=>{
    _spawnCard(c.code, 0, 0);
    const el = cards[cards.length-1].el;
    Object.assign(el.style,{
      left:c.x,top:c.y,width:c.w||'200px',height:c.h||'150px'
    });
  });
}

// ===============================================================
console.log('%cUI-Shell ready','color:#0f0');
============================================================
สิ่งที่ได้ใน v 0.1-alpha

World-Fitting panel แสดง Sphere ทุกตัวหลังโหลด CSV – ลากเข้า canvas เพื่อสร้าง Card
Card ลาก-ยก-ย่อ/ขยายได้ 4 ด้าน, ยก z-index ตามคลิก, ESC ปิด (เพิ่มง่าย)
คำนวณ SUMIF (demo) ผ่าน formulaCard – ถ้าเกิด Error แสดง overlay แดง
Theme toggle (dark → light → high-contrast วน) ใช้ CSS variables
Validate slots, Save / Load layout เป็น JSON
ไม่มี backend, ไม่มีสูตรโผล่, ทุกอย่างทำงานใน browser
============================================================
BACKLOG UI (Week 3)

• Mix-card: Ctrl + Click ≥ 2 ใบ → คลิกขวา “Mix” แล้วให้ผู้ใช้เลือกกราฟ/แกน
• Multi-axis wizard (สูงสุดไม่จำกัด)
• Keyboard a11y: trap focus, Delete = close card
• Error-overlay animation + copy-tooltip
• Resize ghost-preview & grid-snap
