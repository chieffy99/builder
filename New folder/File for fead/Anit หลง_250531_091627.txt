Rethinking Data Models: A New Approach to Flexible, Behavior-Driven Data Structures
Introduction: A Philosophy of Embedded Data Logic
...
Limitations of Conventional Schema-First Systems
...
The Persona–Action Slot String Model
...
StatN and StatC: Logic Flags for Context and Behavior
...
Slots as Vectors of Meaning: Dynamic Yet Structured
...
A Flow-Based Application in CRM and Finance
...
Tool-Agnostic Implementation and Integration
...
Prompting AI and Aligning with Human Thought
...
Conclusion: Toward a Self-Describing, Adaptive Data System
...
การคิดใหม่เกี่ยวกับโมเดลข้อมูล: แนวทางใหม่สำหรับโครงสร้างข้อมูลที่ยืดหยุ่นและขับเคลื่อนด้วยพฤติกรรม บทนำ: ปรัชญาของลอจิกข้อมูลแบบฝัง ระบบข้อมูลแบบเดิมมักจะอาศัยสคีมาที่เข้มงวดและกฎการปรับมาตรฐานที่บังคับให้ความเป็นจริงกลายเป็นตารางที่กำหนดไว้ล่วงหน้า ต้นฉบับนี้สำรวจปรัชญาการเข้ารหัสข้อมูลโดยพื้นฐานที่แตกต่างกัน ซึ่งถือว่าการป้อนข้อมูลแต่ละรายการไม่ใช่เป็นบันทึกคงที่ แต่เป็นประโยคเชิงพฤติกรรม แทนที่จะกระจายข้อมูลไปตามตารางที่ทำให้เป็นมาตรฐาน วิธีการนี้จะฝังบริบท ตรรกะ และความหมายลงในสตริงเดียวโดยตรง แนวคิดหลักคือการรวบรวมข้อมูลในลักษณะที่ลื่นไหลแบบเดียวกับเหตุการณ์ในโลกแห่งความเป็นจริงที่เกิดขึ้น โดยคงบริบททั้งหมด ณ เวลาที่ป้อนข้อมูล ด้วยการทำเช่นนี้ เรามุ่งหวังที่จะขจัดความจำเป็นในการปรับแต่งหลังการประมวลผล การรวม หรือการปรับสคีมาอย่างหนักในบรรทัด ปรัชญานี้ยืนยันว่าหากข้อมูลถูกเข้ารหัสด้วยตรรกะตั้งแต่เริ่มต้น ก็ไม่จำเป็นต้องล้างข้อมูลหรือทำให้เป็นมาตรฐานในภายหลัง กล่าวอีกนัยหนึ่ง ข้อมูลมีสคีมาและกฎการตีความของตัวเองอยู่ภายใน ซึ่งจัดแนวการจัดเก็บข้อมูลให้สอดคล้องกับพฤติกรรมในโลกแห่งความเป็นจริง โดยหัวใจสำคัญของแนวทางนี้ท้าทายสภาพที่เป็นอยู่ของการออกแบบฐานข้อมูล ถาม: เหตุใดเราจึงควรปรับเปลี่ยนกระบวนการทางธุรกิจแบบไดนามิกให้พอดีกับตารางแบบคงที่ แต่เราสามารถบันทึกกระบวนการเหล่านั้นในรูปแบบที่สื่อความหมายได้เองซึ่งเครื่องมือใดๆ (หรือแม้แต่มนุษย์) สามารถอ่านได้ สิ่งนี้แนะนำกรอบความคิดแบบ "พฤติกรรมก่อนสคีมา": ออกแบบรูปแบบข้อมูลตามการกระทำและบริบทที่รูปแบบนั้นเป็นตัวแทน แทนที่จะออกแบบสคีมาก่อนแล้วจึงพยายามทำให้พฤติกรรมสอดคล้องกับรูปแบบนั้น ส่วนต่อไปนี้จะกล่าวถึงข้อจำกัดของการทำให้เป็นมาตรฐานแบบเดิม แนะนำโมเดลสตริงสล็อต persona–action และแสดงให้เห็นถึงข้อได้เปรียบเชิงปฏิบัติในสถานการณ์ CRM และการติดตามทางการเงิน นอกจากนี้เรายังเจาะลึกว่าโมเดลนี้ได้รับการขัดเกลาอย่างไรผ่านการแจ้งของ AI และความหมายในการจัดระบบอัจฉริยะให้สอดคล้องกับตรรกะของมนุษย์ ข้อจำกัดของระบบ Schema-First แบบธรรมดา แนวทางปฏิบัติด้านการศึกษาและการออกแบบฐานข้อมูลส่วนใหญ่มุ่งเน้นไปที่การแยกข้อมูลออกเป็นหลายตารางและฟิลด์ (เอนทิตี คุณลักษณะ คีย์) ซึ่งเป็นกระบวนการที่เรียกว่าการทำให้เป็นมาตรฐาน จุดประสงค์คือเพื่อลดความซ้ำซ้อนและบังคับใช้ความสม่ำเสมอ อย่างไรก็ตาม ในทางปฏิบัติ การออกแบบที่เน้นสคีมาเป็นหลักอาจไม่สอดคล้องกับความต้องการในโลกแห่งความเป็นจริง ประเด็นสำคัญ ได้แก่ : โครงสร้างที่แข็งเกินไป: เมื่อกำหนดสคีมาแล้ว จะไม่ยืดหยุ่น ข้อมูลทางธุรกิจที่แท้จริงนั้นยุ่งเหยิงและพัฒนา สคีมาที่เข้มงวดต้องดิ้นรนเพื่อรองรับธุรกรรมหรือจุดข้อมูลประเภทใหม่ๆ โดยไม่ต้องมีการปรับโครงสร้างใหม่อย่างมีนัยสำคัญ ทุกสิ่งที่ไม่ได้คาดหวังจากการออกแบบดั้งเดิมจะกลายเป็นข้อยกเว้นหรือจำเป็นต้องมีตาราง/คอลัมน์ใหม่ ซึ่งนำไปสู่การเบี่ยงเบนของสคีมาและการย้ายข้อมูลที่ซับซ้อน การแบ่งส่วนบริบท: การทำให้เป็นมาตรฐานจะแบ่งข้อมูลออกเป็นตารางแยกกัน (เช่น ตารางการขาย ตารางลูกค้า ตารางการชำระเงิน) หากต้องการทำความเข้าใจเหตุการณ์ทางธุรกิจหนึ่งๆ (เช่น ลูกค้าซื้อพร้อมส่วนลดและการชำระหนี้) คุณอาจต้องสืบค้นและเข้าร่วมหลายตาราง บริบทหายไปจากความสัมพันธ์เหล่านี้ ต่อมามนุษย์หรือระบบจะต้องปะติดปะต่อเรื่องราวทั้งหมดจากชิ้นส่วนที่กระจัดกระจาย เช่น การประกอบประโยคจากคำแต่ละคำ การป้อนข้อมูลและการดึงข้อมูลที่ไม่มีประสิทธิภาพ: มนุษย์ไม่ได้คิดในตารางฐานข้อมูลโดยธรรมชาติ การป้อนเหตุการณ์ลอจิคัลรายการเดียวอาจต้องกรอกแบบฟอร์มหรือฟิลด์หลายรายการในส่วนต่างๆ ของแอปพลิเคชัน เนื่องจากข้อมูลถูกแบ่งเป็นส่วนประกอบที่ทำให้เป็นมาตรฐาน การกระจายตัวนี้สามารถทำให้เกิดข้อผิดพลาดในการป้อนข้อมูลและความยุ่งยากได้ ในด้านการรับข้อมูล การตอบคำถามง่ายๆ (เช่น “เกิดอะไรขึ้นกับลูกค้า X ในวันที่ Y?”) อาจจำเป็นต้องมีการสืบค้นที่ซับซ้อนเพื่อเข้าร่วมหลายตาราง ความซับซ้อนนี้เกิดข้อผิดพลาดได้ง่ายและเป็นภาระทั้งนักพัฒนาและผู้ใช้ การทำความสะอาดภายหลังเฉพาะกิจ ("ทำให้เป็นมาตรฐานหลังจากข้อเท็จจริง"): หากข้อมูลไม่ได้รับการบันทึกในรูปแบบที่สอดคล้องกัน องค์กรต่างๆ จะต้องดำเนินการทำความสะอาดจำนวนมากและ "ทำให้เป็นมาตรฐาน" ในภายหลัง โดยเป็นการรวมหมวดหมู่ที่ควรเป็นหมวดหมู่เดียว เติมเต็มช่องว่าง และแก้ไขข้อผิดพลาดในการจำแนกประเภท การทำให้เป็นมาตรฐานเชิงโต้ตอบนี้โดยพื้นฐานแล้วจะชดเชยกระบวนการป้อนข้อมูลที่อนุญาตให้มีข้อมูลที่ไม่สอดคล้องกันตั้งแต่แรก หลักการชี้นำประการหนึ่งของแนวทางใหม่นี้คือ “ไม่มีระบบใดที่ควรจะต้องทำให้อินพุตเป็นมาตรฐาน หากอินพุตถูกเข้ารหัสอย่างมีเหตุผลตั้งแต่แรก” ความจำเป็นในการแก้ไขข้อมูลในภายหลังหมายความว่ามีบางสิ่งที่ได้รับอนุญาตให้เกิดข้อผิดพลาดเมื่อเข้ามา (ไม่ว่าจะเกิดจากข้อผิดพลาดของมนุษย์หรือข้อจำกัดของเครื่องมือ) Schema-Tool Bias: ผู้ที่ได้รับการฝึกอบรมเกี่ยวกับการออกแบบฐานข้อมูลแบบคลาสสิกมักจะมุ่งเน้นไปที่เครื่องมือและการสืบค้น (คำสั่ง SQL, ORM ฯลฯ) มากกว่าแก่นแท้ของข้อมูล พวกเขาสร้างสคีมาที่ปรับให้เหมาะสมสำหรับเครื่องมือเหล่านั้น (การรวมอย่างรวดเร็ว การจัดทำดัชนี) แต่ไม่จำเป็นต้องปรับให้เหมาะสมเพื่อการทำความเข้าใจหรือสะท้อนกระแสธุรกิจ ตัวอย่างเช่น การมุ่งเน้นด้านการศึกษาเกี่ยวกับคีย์หลักและคีย์นอก โดยไม่มีการเน้นที่เท่าเทียมกันในความแตกต่างระหว่างข้อมูลอ้างอิงคงที่ (เช่น รายการราคา ชื่อบัญชี) และข้อมูลธุรกรรมแบบไดนามิก นำไปสู่ระบบที่ได้รับการออกแบบทางวิศวกรรมมากเกินไปหรือเข้มงวดเกินไปสำหรับการดำเนินงานในแต่ละวัน ในที่สุดเราก็ได้นักออกแบบที่เก่งในการใช้ SQL หรือ Excel แต่ระบบที่พวกเขาสร้างอาจเปราะบางเนื่องจากไม่ได้จัดลำดับความสำคัญของรูปแบบการใช้งานในโลกแห่งความเป็นจริง โดยสรุป ฐานข้อมูลมาตรฐานที่เน้นสคีมาแบบเดิมๆ อาจเปราะบาง ซับซ้อนเกินไป และไม่สอดคล้องกับวิธีการใช้หรือสร้างข้อมูลจริง พวกเขาต้องการให้เราปรับกระบวนการของมนุษย์เข้ากับฐานข้อมูล แทนที่จะปรับฐานข้อมูลให้เข้ากับกระบวนการของมนุษย์ นี่เป็นการปูทางสำหรับแนวทางใหม่โดยมีเป้าหมายเพื่อฝังความฉลาดและความยืดหยุ่นที่มากขึ้นลงในรูปแบบข้อมูลโดยตรง โดยจับบริบท ณ จุดเริ่มต้น โมเดลสตริงสล็อต Persona – Action เพื่อแก้ไขข้อบกพร่องเหล่านี้ เราขอเสนอแบบจำลองที่เข้ารหัสธุรกรรมหรือเหตุการณ์ทั้งหมดเป็นสตริงที่มีโครงสร้างเพียงสตริงเดียว สตริงนี้เป็นประโยคสั้นๆ ที่อธิบาย who–do–what พร้อมด้วยรายละเอียดที่จำเป็น เราเรียกมันว่าโมเดลสล็อตบุคคล–การกระทำ เนื่องจากโมเดลจะมีตัวระบุสองตัวเสมอ (บุคคลและการกระทำ) ตามด้วยชุดของสล็อตที่มีค่าหรือบริบท นอกจากนี้ยังมีรหัสสถานะสองส่วนสำหรับตรรกะ โดยพื้นฐานแล้วแต่ละรายการจะสรุป: Persona ID (ID1): ใครหรืออะไรที่เป็นหัวข้อของการทำธุรกรรม นี่อาจเป็นบุคคล บทบาท หรือประเภทเอนทิตี (เช่น ลูกค้า พนักงาน ซัพพลายเออร์ ฯลฯ ขึ้นอยู่กับบริบท) บุคคลนั้นเป็นเหมือนประธานไวยากรณ์ของประโยค รหัสการดำเนินการ (ID2): บุคคลกำลังดำเนินการใดอยู่ นี่คือกริยาที่เข้ารหัสซึ่งอธิบายประเภทธุรกรรมหรือประเภทเหตุการณ์ (เช่น "BY" อาจหมายถึงการซื้อ "CR" สำหรับขอเครดิต "RE" สำหรับการชำระคืน ฯลฯ) การกระทำก็เหมือนกับกริยาของประโยค StatN (รหัสสถานะตัวเลข) และ StatC (รหัสสถานะอักขระ): ทั้งสองนี้ทำหน้าที่เป็นแฟล็กตรรกะหรือไวยากรณ์ขนาดเล็กที่บอกเราว่าจะตีความช่องที่ตามมาอย่างไร StatN เป็นตัวเลขตัวเดียว (0–9) และ StatC เป็นตัวอักษรตัวเดียว (A–Z) รหัสเหล่านี้แสดงถึงสิ่งต่างๆ เช่น หมวดหมู่ของธุรกรรมและลักษณะของมูลค่าที่ให้ไว้ ตัวอย่างเช่น รหัสตัวเลขอาจแยกแยะระหว่างธุรกรรมเงินสดกับธุรกรรมเครดิต หรือการชำระเงินเทียบกับการโอน ฯลฯ ในขณะที่รหัสอักขระอาจระบุว่าตัวเลขในช่องเป็นจำนวนดิบ จำนวนเงินในสกุลเงิน เปอร์เซ็นต์ ฯลฯ เราจะดูรายละเอียดเพิ่มเติมเกี่ยวกับรหัสเหล่านี้ในไม่ช้า สิ่งสำคัญที่สุดคือ ธงเล็กๆ ทั้งสองนี้เข้ารหัสสิ่งที่หลายระบบอาจจัดการด้วยคอลัมน์ที่แยกจากกัน เช่น “transaction_type”, “is_credit”, “is_computed” ฯลฯ ซึ่งทั้งหมดนี้อยู่ในอักขระสองตัว (โดยเฉพาะอย่างยิ่ง ไม่จำเป็นต้องป้อนรหัสเหล่านี้ด้วยตนเองทุกครั้ง เนื่องจากสามารถอนุมานได้จากบริบทหรือค่าเริ่มต้น ทำให้ผู้ใช้ง่ายขึ้น) ช่อง 1...N: ลำดับของช่อง (แต่ละช่องอาจเป็นตัวเลขหรือข้อความก็ได้) ที่มีพารามิเตอร์หรือค่าจริงของเหตุการณ์ ความหมายของแต่ละตำแหน่งสล็อตถูกกำหนดโดยการรวมกันของรหัสการดำเนินการและสถานะ คิดว่าแต่ละช่องเป็นตัวถูกดำเนินการหรือรายละเอียดของการดำเนินการ ตัวอย่างเช่น ในธุรกรรมการขาย slot1 อาจเป็นปริมาณที่ขาย slot2 คือตัวระบุผลิตภัณฑ์หรือหมวดหมู่ slot3 อาจเป็นหมวดหมู่ย่อยหรือวิธีการขาย ฯลฯ ในขณะที่ธุรกรรมบัญชีเงินเดือน ช่องเหล่านั้นอาจหมายถึงบางสิ่งที่แตกต่างไปจากเดิมอย่างสิ้นเชิง (เช่น ชั่วโมงทำงาน อัตรา ฯลฯ) สิ่งสำคัญคือตำแหน่งของช่องมีความหมายเชิงความหมายในบริบทของการกระทำนั้น ตามแบบแผน ช่องทั้งหมดจะถูกกรอกตามลำดับ (หากไม่ได้ใช้ช่องใดช่องหนึ่ง จะมีการวางค่าเริ่มต้นเช่น 0 เพื่อรักษาความต่อเนื่องของตำแหน่ง) เพื่อให้แน่ใจว่าส่วนของสายอักขระจะไม่เลื่อนไปมา ลำดับคงที่หมายความว่าหมายเลขช่องที่กำหนดจะอ้างอิงถึงข้อมูลประเภทเดียวกันสำหรับประเภทการกระทำที่กำหนดเสมอ โครงสร้างตัวอย่าง: ลองนึกภาพรายการสตริงที่เข้ารหัสอย่างง่าย: ซีเอสเอส สำเนา แก้ไข [วันที่], [ID1], [ID2], [StatN], [StatC], [slot1], [slot2], ... [slotN] แต่ละส่วนจะถูกคั่นด้วยเครื่องหมายจุลภาค (สำหรับความเข้ากันได้ของ CSV) หรือตัวคั่นอื่นที่สอดคล้องกัน วันที่ (หรือการประทับเวลา) สามารถใส่คำนำหน้าสตริงสำหรับการติดตามตามลำดับเวลา แต่แกนหลักของโมเดลคือลำดับจาก ID1 ถึงช่อง ตัวอย่างอาจมีลักษณะดังนี้: ซีเอสเอส สำเนา แก้ไข 2025/04/01, SH01, BY, 0, B, 5, 0, 0, 0 ทำลายสิ่งนี้: SH01 อาจเป็นบุคคล (เช่น รหัสลูกค้า SH01) BY คือโค้ดการดำเนินการ ซึ่งอาจหมายถึง "ซื้อ" (เหตุการณ์การซื้อ) 0 คือ StatN ซึ่งเป็นรหัสตัวเลข (ในที่นี้ 0 อาจหมายถึงธุรกรรมเงินสด) B คือ StatC ซึ่งเป็นรหัสอักขระ (ในที่นี้ B อาจย่อมาจาก "ค่าการนับ" ซึ่งบ่งชี้ว่าช่องมีจำนวนที่ต้องแปลงเป็นค่า) ช่อง 5, 0, 0, 0 ที่ตามมาอาจแสดงถึงรายละเอียดของการซื้อ ในบริบทนี้ slot1 = 5 อาจหมายถึงมีการซื้อผลิตภัณฑ์ 5 หน่วย และช่องอื่นๆ เป็นศูนย์เนื่องจากไม่ได้ใช้สำหรับการดำเนินการเฉพาะนี้ (เป็นเพียงตัวยึดตำแหน่งเพื่อให้โครงสร้างสอดคล้องกัน) ดังนั้นรายการทั้งหมดนี้โดยย่อหมายถึง: ลูกค้า SH01 ซื้อ 5 หน่วย (ธุรกรรมเงินสด) ระบบรู้วิธีการตีความ "5 หน่วย" เนื่องจากรหัส B (จำนวนนับ) รวมกับการดำเนินการ BY หากนี่เป็นการผสมโค้ดที่แตกต่างกัน ความหมายของ 5 ในช่อง 1 อาจเป็นอย่างอื่นได้ (เช่น จำนวนเงิน ถ้า StatC เป็น A สำหรับค่า) ตอนนี้ให้พิจารณาตัวอย่างที่ซับซ้อนกว่านี้เล็กน้อย: รวดเร็ว สำเนา แก้ไข 2025/04/01, MK02, อีกครั้ง, 2, A, 0, 0, 0, 0, 150 ที่นี่: MK02 อาจเป็นรหัสบุคคลสำหรับพนักงานหรืออาจเป็นร้านค้าหรือแผนกเฉพาะ สมมติว่า MK02 เป็นรหัสพนักงาน RE เนื่องจากการกระทำอาจหมายถึง "การชำระคืน" (เช่น การชำระหนี้) StatN = 2 สามารถระบุได้ว่านี่คือธุรกรรมการชำระหนี้ (ในระบบรหัสของเรา เราอาจกำหนด 1 = บันทึกหนี้ (การขายเครดิต) และ 2 = การชำระหนี้) StatC = A สามารถระบุได้ว่าค่าที่กำหนดเป็นจำนวนเงินสุดท้าย (A สำหรับจำนวนเงินที่คำนวณได้) ช่องคือ 0,0,0,0,150 หากการดำเนินการนี้ไม่จำเป็นต้องมีฟิลด์รายละเอียดระดับกลาง ช่องสี่ช่องแรกจะเป็นศูนย์ ช่องสุดท้าย 150 (สมมติว่านี่คือช่อง 5 หรือช่อง 7 ขึ้นอยู่กับวิธีการนับของเรา แต่ไม่ว่าในกรณีใด ค่าสุดท้าย) แสดงถึงจำนวนเงิน 150 ที่จะจ่าย เมื่อกำหนด StatN=2 (การชำระหนี้) และ StatC=A (จำนวนเงินสุดท้าย) ระบบจะตีความสิ่งนี้เป็น: พนักงาน MK02 ชำระคืน 150 (หน่วยสกุลเงิน) เป็นหนี้ โครงสร้างได้รวบรวมว่าใคร (MK02) การกระทำใด (การชำระคืน) บริบท (เป็นการชำระหนี้เทียบกับการขายเงินสด ฯลฯ จากรหัส) และมูลค่า (150 ของสกุลเงิน) ทั้งหมดนี้อยู่ในบรรทัดเดียวโดยไม่ต้องมีตาราง "บัญชีแยกประเภทหนี้" แยกต่างหากหรือรวมตารางใบแจ้งหนี้และตารางการชำระเงิน สิ่งสำคัญคือต้องทราบว่าแต่ละส่วนของสตริงมีความหมายทั้งในตัวมันเองและรวมกัน บุคลิกและการกระทำร่วมกันกำหนดบริบท (เช่น “ลูกค้าซื้อ” กับ “พนักงานจ่ายคืน”) ธง StatN/StatC ปรับแต่งวิธีการประมวลผล (เช่น ถือว่าตัวเลขเป็นปริมาณเทียบกับสกุลเงิน จัดการเป็นเงินสดหรือตรรกะเครดิต) และช่องต่างๆ จะให้รายละเอียดที่เป็นตัวเลขหรือหมวดหมู่ตามลำดับคงที่ ในแง่ไวยากรณ์ คุณสามารถพูดได้ว่า ID1 เป็นประธาน ID2 เป็นคำกริยา และช่องที่รวมกันทำหน้าที่เหมือนกรรมของประโยค (โดยที่ StatN/StatC เป็นเครื่องหมายวรรคตอนหรือน้ำเสียงที่สามารถเปลี่ยนความแตกต่างของวัตถุได้) เหตุผลในการออกแบบ: เพราะเหตุใด Persona + Action (ไม่มี Object ID) อาจมีคนถามว่าทำไมมีเพียงสอง ID (ID1 และ ID2)? การคิดแบบเดิมๆ อาจเสนอแนะสามประการ: ประธาน กริยา กรรม (เช่น ลูกค้า X (หัวเรื่อง) ซื้อ (กริยา) สินค้า Y (วัตถุ)) ในตอนแรก มีการพิจารณาแนวคิดในการรวม ID ที่สาม (สำหรับวัตถุ) เข้าด้วยกัน อย่างไรก็ตาม สิ่งนี้ถูกจงใจหลีกเลี่ยงด้วยเหตุผลหลายประการ: ความซับซ้อนและการบำรุงรักษา: การแนะนำ ID ออบเจ็กต์ (ID3) จะหมายถึงทุกธุรกรรมอาจต้องอ้างอิงเอนทิตีภายนอก (เช่น ID ผลิตภัณฑ์หรือ ID บริการ) เป็นออบเจ็กต์ สิ่งนี้เริ่มคืบคลานกลับไปสู่โมเดลเชิงสัมพันธ์ (การลิงก์ไปยังตารางผลิตภัณฑ์ ฯลฯ) และยังจะทำให้โครงสร้างสตริงซับซ้อนอีกด้วย จุดมุ่งหมายคือเพื่อให้แต่ละรายการมีอยู่ในตัวเองและน้อยที่สุด ไม่ใช่เว็บของ ID ที่ต้องมีการค้นหา การเพิ่ม ID อื่นยังหมายถึงการจัดการที่มากขึ้น (ตรวจสอบให้แน่ใจว่ามี ID วัตถุอยู่ การทำให้เป็นมาตรฐาน ฯลฯ) ทำให้เกิดความซับซ้อนบางอย่างที่เราต้องการกำจัดอีกครั้ง ออบเจ็กต์ที่ฝังผ่านสล็อต: ในโมเดลนี้ “ออบเจ็กต์” ของธุรกรรมมักจะอยู่ในสล็อตโดยปริยาย หรือเป็นค่าคงที่ที่กำหนดโดยการผสมผสานระหว่างบุคคลและการกระทำ ตัวอย่างเช่น ถ้า ID1 เป็นลูกค้า และ ID2 คือ "BY" (ซื้อ) รายการจริงที่ซื้อสามารถแสดงในช่อง (ไม่ว่าจะเป็นประเภทหรือจำนวนหรือจำนวนเงิน) หาก ID1 เป็นหมวดหมู่ เช่น "สินค้าคงคลัง" และ ID2 เป็น "เพิ่ม" ช่องอาจอธิบายว่ารายการใดถูกเพิ่ม ในหลายกรณี วัตถุสามารถได้รับมาจากบริบท ช่องดังกล่าวอาจมีรหัสผลิตภัณฑ์หรือคำอธิบายหากจำเป็น หรือรหัสการดำเนินการเองก็บ่งบอกถึงออบเจ็กต์บางอย่าง โดยพื้นฐานแล้ว โมเดลเลือกที่จะเข้ารหัสรายละเอียดของออบเจ็กต์ในช่องแทนที่จะเป็นการอ้างอิงคีย์ต่างประเทศที่แยกต่างหาก สิ่งนี้ทำให้สตริงสามารถพึ่งพาตนเองได้มากขึ้น AI และการจัดตำแหน่งทางปัญญา: สิ่งที่น่าสนใจคือทางเลือกในการหลีกเลี่ยง ID อ็อบเจ็กต์ที่ชัดเจนยังมีผลกระทบต่อการตีความของ AI และการรับรู้ของมนุษย์อีกด้วย แบบจำลองนี้หลีกเลี่ยงโครงสร้าง SVO (ประธาน-กริยา-วัตถุ) ที่เหมือนภาษาธรรมชาติโดยสมบูรณ์ เพราะถ้าเราให้ AI หรือแม้แต่ผู้อ่านบางอย่างที่ดูเหมือนประโยคทุกประการ พวกเขาอาจกำหนดให้มีอคติทางภาษาตามธรรมชาติ โดยการรักษาให้เข้ากับบุคคลและการกระทำ เราจะแนะนำการตีความ: ส่วนที่สาม (วัตถุ) ไม่ใช่ตัวระบุเดียว แต่เป็นเพย์โหลดที่มีโครงสร้าง (ช่อง) ด้วยวิธีนี้ แม้แต่ AI ที่อ่านสตริงเป็นรูปแบบก็จะเรียนรู้ว่าหลังจากตัวระบุสองตัว รหัสและรายการค่าจะมาหลังจากตัวระบุสองตัว แทนที่จะพยายามอ่านเป็น "[ID1] ทำ [ID2] ถึง [ID3]" ในการทดสอบพบว่าถ้าเรารวมรหัสวัตถุ AI อาจพยายามปฏิบัติต่อสิ่งทั้งหมดเป็นประโยคที่ตรงไปตรงมาและตีความความสัมพันธ์ผิดหรือเรียบง่ายเกินไป ด้วย ID เพียงสองรหัส สตริงยังคงเป็น "แผนผัง" เล็กน้อย ซึ่งดีสำหรับการแยกวิเคราะห์เครื่อง ในขณะที่มนุษย์ยังสามารถอ่านได้หากมีการฝึกอบรมเพียงเล็กน้อย โดยสรุป โมเดลบุคคลและการกระทำเป็นจุดที่น่าสนใจ โดยรวบรวมนักแสดงและการกระทำที่สำคัญในรูปแบบกะทัดรัด และมอบรายละเอียดส่วนที่เหลือให้กับโครงสร้างสล็อต ทำให้ข้อมูลสามารถอธิบายได้ด้วยตนเองแต่ไม่ละเอียดจนเกินไป ไม่มีสิ่งใดในธุรกรรมที่ไม่ได้เข้ารหัสในบรรทัดนั้น โดยจะมีคีย์ (ID) ประเภท (รหัส) และค่า (สล็อต) ทั้งหมดในที่เดียว ในส่วนถัดไป เราจะเจาะลึกลงไปในโค้ด StatN และ StatC และระบบสล็อต เนื่องจากโค้ดเหล่านี้เป็นแกนหลักที่ให้พลังลอจิคัลแก่สตริงเหล่านี้ StatN และ StatC: แฟล็กลอจิกสำหรับบริบทและพฤติกรรม StatN (หมายเลขสถานะ) และ StatC (อักขระสถานะ) เป็นโค้ดขนาดเล็กสองตัวที่รวมกันแล้วกำหนด "กฎ" หรือเฟรมเวิร์กการตีความสำหรับรายการที่กำหนด โดยพื้นฐานแล้วพวกเขาบอกระบบการประมวลผลใด ๆ ว่า “ฉันจะปฏิบัติต่อค่าในช่องอย่างไร นี่เป็นธุรกรรมประเภทใด” ฟิลด์ทั้งสองนี้จะแทนที่สิ่งที่ในระบบปกติอาจเป็นชุดคอลัมน์หรือแฟล็กทั้งชุด (เช่น รหัสประเภทธุรกรรม บูลีนสำหรับเครดิต/เดบิต แฟล็กสำหรับการคำนวณหรือไม่ ฯลฯ) ด้วยการเข้ารหัสด้วยโค้ดสองตัว เราจะรักษาสตริงให้สั้นแต่ยังคงความหมายที่สมบูรณ์ไว้ StatN (รหัสตัวเลข 0–9): โดยทั่วไปจะใช้เพื่อแสดงหมวดหมู่ธุรกรรมแบบกว้างหรือตรรกะทางการเงิน แต่ละหลักถูกกำหนดไว้ในตารางกฎ ตัวอย่างเช่น ระบบอาจกำหนด: 0 = เงินสด 1 = เครดิต (บัญชีลูกหนี้) 2 = การชำระหนี้ 3 = การโอน ฯลฯ คำจำกัดความเหล่านี้บอกคุณว่าควรใช้วิธีปฏิบัติทางการเงินหรือทางธุรกรรมประเภทใด ถ้า StatN เป็น 0 (เงินสด) ค่าอาจส่งผลโดยตรงต่อยอดเงินสด ถ้า StatN คือ 1 (เครดิต) อาจหมายถึงการบันทึกลูกหนี้ (และยังไม่ใช่กระแสเงินสดจริง) หาก StatN เป็น 2 หมายความว่ารายการนี้เกี่ยวข้องกับการชำระหนี้ (ซึ่งในแบบจำลองของเรามักจะหมายถึงการดูที่ slot7 ดังที่เราจะได้เห็น) ประเด็นสำคัญคือ StatN ระบุลักษณะของธุรกรรมในแง่ของการทำบัญชีหรือการไหล ผู้ใช้ที่ป้อนข้อมูลไม่จำเป็นต้องคิดถึงตัวเลขนี้ สามารถตั้งค่าได้โดยอัตโนมัติตามการกระทำหรือบริบท (เช่น การดำเนินการซื้อ "BY" ใดๆ อาจมีค่าเริ่มต้นเป็น StatN 0 สำหรับเงินสด เว้นแต่จะเป็นการขายเครดิตโดยเฉพาะ เป็นต้น) StatC (รหัสอักขระ A–Z): รหัสนี้ระบุการตีความค่าสล็อต โดยพื้นฐานแล้วคือการวัดหรือหน่วยของค่าเหล่านั้น ตัวอย่างความหมายบางส่วนที่เราได้กำหนดไว้: A = “จำนวนเงิน” หรือมูลค่าผลลัพธ์ ซึ่งหมายความว่าค่าของช่อง (โดยเฉพาะช่องสุดท้ายหรือช่องใดช่องหนึ่ง) แสดงถึงจำนวนเงินหรือมูลค่าที่คำนวณได้ขั้นสุดท้าย หากรายการมี StatC = A เรารู้ว่าเรากำลังจัดการกับมูลค่าทางการเงินที่สรุปหรือสรุปแล้ว B = “จำนวนพื้นฐาน” หรือมูลค่าการนับ สิ่งนี้บ่งชี้ว่าตัวเลขในช่องเป็นการนับหรือหน่วยดิบที่จะถูกแปลงเป็นจำนวนเงินผ่านตรรกะการกำหนดราคาหรือการคำนวณบางอย่าง ตัวอย่างเช่น ในรายการการขายที่มี StatC = B ช่องอาจระบุว่า "5" หมายถึงผลิตภัณฑ์ 5 หน่วย และบางแห่งระบบรู้วิธีแปลงสิ่งนั้นเป็นรายได้ โดยพื้นฐานแล้ว B กล่าวว่า “ช่องเหล่านี้เป็นข้อมูลเชิงปริมาณ แต่ยังไม่ใช่ตัวเงิน” C = “ค่าคงที่” หรือค่าคงที่ ซึ่งสามารถใช้สำหรับค่าที่มาจากการอ้างอิงหรือคงที่ ตัวอย่างเช่น อาจเป็นอัตราดอกเบี้ยหรืออัตราภาษีที่ดึงมาจากตารางอ้างอิง การใช้ C สามารถทำเครื่องหมายว่าช่องนั้นเป็นการค้นหาค่าคงที่ (หากบริบทของเราคือพื้นที่โฆษณา บางที C อาจทำเครื่องหมายปัจจัยการแปลงคงที่หรือมูลค่าเกณฑ์) นี่เป็นเพียงโค้ดประกอบบางส่วนเท่านั้น โมเดลรองรับตัวเลขสูงสุด 10 หลักและตัวอักษร 26 ตัว ซึ่งสามารถขยายได้ตามต้องการสำหรับการแยกตรรกะต่างๆ การรวมกันของ StatN และ StatC ให้ความยืดหยุ่นอย่างมาก ตัวอย่างเช่น 0B กับ 0A ในสองรายการที่คล้ายกันจะบอกเราว่ารายการหนึ่งระบุปริมาณที่ต้องคูณ (B) ในขณะที่อีกรายการระบุจำนวนสุดท้าย (A) 1A อาจระบุการขายเครดิตด้วยจำนวนเงิน (หมายถึงรายได้รับรู้เป็นเครดิต) ในขณะที่ 0A อาจระบุยอดขายเงินสดทันที กฎของระบบอาจสรุปเป็นตารางรหัส ตัวอย่างเช่น: รหัส StatN ความหมาย (ประเภทรายการ) ผล 0 การทำธุรกรรมเงินสด (ชำระเงินทันที) ส่งผลกระทบต่อเงินสดคงเหลือ ไม่มีการสร้างลูกหนี้ 1 ธุรกรรมสินเชื่อ (ในบัญชี) สร้าง/ส่งผลกระทบต่อบัญชีลูกหนี้ (หนี้) 2 การชำระหนี้ (การชำระหนี้) ใช้ช่องการชำระหนี้ (เช่น slot7) เพื่อลดหนี้คงค้าง 3 รายการโอนเงิน (เคลื่อนไหวที่ไม่ใช่เงินสด) ระบุการโอนเงินผ่านธนาคารหรือการย้ายภายใน ปฏิบัติที่แตกต่างจากเงินสด
·        (สูงสุด 9 รายการสำหรับหมวดหมู่อื่นๆ ตามความจำเป็น) (ขยายได้ตามต้องการ) และสำหรับ StatC: รหัส StatC ความหมาย (ประเภทค่า) คำอธิบาย ก จำนวนผลลัพธ์ (มูลค่าสุดท้าย) ช่องประกอบด้วยค่าที่คำนวณสุดท้าย (เช่น สกุลเงิน) ที่พร้อมที่จะโพสต์ บี จำนวน/ปริมาณ (ที่จะแปลง) ช่องประกอบด้วยจำนวนหรือหน่วยดิบ (จะคูณด้วยราคาหรืออัตรา) ค ค่าคงที่/ค่าอ้างอิง ช่องมีค่าคงที่จากการอ้างอิง (ใช้สำหรับการค้นหาหรือการคำนวณคงที่)
·        (D–Z สำหรับการใช้งานอื่น ๆ ) (สามารถกำหนด D = เปอร์เซ็นต์, E = รหัสข้อผิดพลาด ฯลฯ ได้ตามต้องการ) วิธีที่ StatN/StatC ทำงานร่วมกัน: รหัสเหล่านี้จะถูกตีความควบคู่กับบุคลิกและการกระทำเสมอ ตัวอย่างเช่น พิจารณา ID1 = SH11 (ลูกค้า), ID2 = CR (การดำเนินการบางอย่าง “คำขอเครดิต”), StatN = 1, StatC = A โดยมีจำนวนเงินในช่อง นี่อาจหมายถึง "ลูกค้า SH11 ร้องขอเครดิตจำนวน [จำนวน]" - StatN 1 (เครดิต) รวมกับ StatC A (จำนวน) จะบอกระบบว่ากำลังบันทึกหนี้ใหม่ (ไม่ใช่การเคลื่อนย้ายเงินสด) ของมูลค่าที่แน่นอน หาก StatC เป็น B แทน อาจหมายความว่าลูกค้าขอเครดิตสำหรับบางสิ่งจำนวนหนึ่ง ซึ่งระบบอาจแปลงเป็นค่าผ่านกฎการกำหนดราคา แง่มุมหนึ่งที่ทรงพลังก็คือ ผู้ใช้ปลายทางไม่ได้พิมพ์ StatN และ StatC เองสำหรับแต่ละรายการ ในกรณีส่วนใหญ่ พวกเขาสามารถกำหนดได้โดยอัตโนมัติ ผู้ใช้อาจเลือก "การขายเงินสด" หรือ "การขายเครดิต" ใน UI ซึ่งภายใต้ประทุนจะตั้งค่า StatN อย่างเหมาะสม หรือแบบฟอร์ม "เพิ่มสินค้าคงคลัง" อาจตั้งค่า StatN เป็นประเภทการโอนโดยอัตโนมัติ ผู้ใช้อาจเลือกโหมดหน่วยเทียบกับจำนวน โดยตั้งค่า StatC ทางอ้อม ดังนั้นรูปแบบสตริงจึงเป็นมิตรสำหรับผู้ใช้แบ็คเอนด์และผู้ใช้ระดับสูง แต่ผู้ใช้ทั่วไปสามารถโต้ตอบกับแบบฟอร์มที่ซ่อนโค้ดเหล่านี้ได้ อย่างไรก็ตาม เมื่อบันทึกแล้ว ระบบใดก็ตามที่อ่านสตริงจะสามารถทราบวิธีการประมวลผลได้ทันทีโดยไม่ต้องมีบริบทเพิ่มเติม ไม่มีชิ้นส่วนที่ขาดหายไป: การออกแบบกำหนดให้ช่องทั้งหมดในสตริงถูกครอบครองตามลำดับ (ไม่มีช่องว่าง) หากช่องใดช่องหนึ่งไม่มีค่าที่ใช้ได้ ช่องนั้นจะถูกกรอกด้วยค่าเริ่มต้น (โดยทั่วไปคือ 0 หรือตัวยึดตำแหน่งว่าง) เหตุผลก็คือเพื่อรักษาความหมายตำแหน่ง – ลำดับสล็อตเป็นสิ่งศักดิ์สิทธิ์ ด้วยวิธีนี้ หากคุณเห็นบางอย่างในช่อง 4 คุณจะรู้ได้อย่างชัดเจนว่าช่องนั้นสอดคล้องกับประเภทการกระทำนั้น (เนื่องจากมีช่อง 1–3 ที่อยู่ก่อนหน้าอยู่ แม้ว่าจะเป็น 0 ก็ตาม) สตริง “รู้” ว่าแต่ละตำแหน่งหมายถึงอะไร ซึ่งจะช่วยลดความต้องการข้อมูลเมตาภายนอกหรือคำจำกัดความของสคีมาในการตีความตำแหน่ง กล่าวอีกนัยหนึ่ง ตำแหน่งคือข้อมูลเมตา ตามตัวอย่าง หาก slot6 ถูกกำหนดเป็น "จำนวนส่วนลด" ในบริบทของการขาย ในทุกรายการที่เกี่ยวข้องกับการขาย ฟิลด์ที่หกหลังจาก StatC จะแสดงส่วนลด (และหากไม่มีส่วนลด อาจเป็น 0) หาก slot7 ถูกกำหนดให้เป็น “การชำระหนี้ (DebPaid)” มันจะปรากฏเป็นช่องที่เจ็ดเสมอเมื่อมีความเกี่ยวข้อง (และเป็น 0 เมื่อไม่เกี่ยวข้อง) ความสอดคล้องนี้คือสิ่งที่ช่วยให้โค้ดหรือสูตรง่ายๆ สามารถแยกวิเคราะห์รายการและสรุปผลรวมที่มีความหมายได้ สล็อตเป็นเวกเตอร์แห่งความหมาย: ไดนามิก แต่มีโครงสร้าง ส่วนช่องของสตริงอาจดูเหมือนเป็นช่องเก็บของ แต่จริงๆ แล้วมันเป็นเวกเตอร์เชิงตรรกะที่สามารถตีความได้แตกต่างกันภายใต้การกระทำที่แตกต่างกัน (และรหัสสถิติ) แต่ละตำแหน่งสล็อตมีบทบาทที่กำหนดไว้ตามบริบท การออกแบบนี้ช่วยให้แบบจำลองเป็นแบบไดนามิก (จำนวนช่องตัวแปรตามต้องการ) แต่มีโครงสร้าง (แต่ละตำแหน่งช่องได้รับการกำหนดไว้อย่างดีในสถานการณ์ที่กำหนด) ลองนึกถึงช่อง 1–N ว่าเป็นอาร์เรย์แบบยืดหยุ่น โดยที่ N สามารถขยายเพื่อรองรับรายละเอียดได้มากขึ้นหากจำเป็น แต่สำหรับประเภทการดำเนินการที่กำหนด จำนวนและความหมายของช่องจะถูกกำหนดไว้ล่วงหน้า ตัวอย่างเช่น คุณอาจตัดสินใจว่าธุรกรรมการขายใช้ช่องที่ 1–5 ในขณะที่การปรับปรุงทางการเงินที่ซับซ้อนอาจใช้ช่องที่ 1–7 หรือเหตุการณ์บัญชีเงินเดือนของ HR อาจใช้ช่อง 1–4 (สำหรับชั่วโมง อัตรา ฯลฯ) รูปแบบสามารถปรับได้ แต่ถึงกระนั้น แต่ละการกระทำที่กำหนดไว้จะมีสคีมาคงที่ในแง่ของความหมายของช่อง ตัวอย่าง: ช่องสินค้าคงคลังเทียบกับช่องทางการเงิน – เพื่อให้เห็นภาพ ให้พิจารณาธุรกิจที่ติดตามทั้งความเคลื่อนไหวของสินค้าคงคลังและบันทึกทางการเงิน พวกเขากำหนดช่องในลักษณะที่เป็นหนึ่งเดียว แต่ตีความตามบริบท: ช่อง 1–5: ช่องรายการอเนกประสงค์ ในบริบทของสินค้าคงคลัง สิ่งเหล่านี้อาจแสดงรายการผลิตภัณฑ์หรือส่วนประกอบต่างๆ ที่เกี่ยวข้องกับธุรกรรม ในบริบททางการเงินเพียงอย่างเดียว (เช่น รายการค่าใช้จ่าย) ช่องเดียวกันเหล่านั้นอาจมีคำอธิบายหรือหมวดหมู่ย่อยที่ไม่ได้รวมเข้ากับสิ่งใดโดยตรง หรืออาจว่างเปล่า (0) หากไม่จำเป็น โดยพื้นฐานแล้ว ช่องที่ 1–5 สามารถระบุรายการหรือหมวดหมู่ได้ ช่องที่ 6: ช่องปรับพิเศษ ในสินค้าคงคลัง บางที slot6 อาจบันทึกจำนวนสินค้าแจกฟรีหรือส่วนลด (เช่น สินค้าที่แจกฟรี หรือการปรับสต๊อกสินค้าที่ไม่ใช่การขาย) ในธุรกรรมทางการเงิน slot6 อาจใช้ไม่ได้เลย (อาจเป็น 0 ได้) หรือหากบริบทเป็นใบแจ้งหนี้การขาย slot6 อาจแสดงถึงส่วนลดที่ให้ (ในหน่วยหรือจำนวนเงินขึ้นอยู่กับ StatC) โดยทั่วไปแล้ว อาจกำหนด slot6 เป็น "ส่วนลด/การปรับปรุง" ช่องที่ 7 สงวนไว้สำหรับการชำระหนี้หรือยกยอด การออกแบบที่เราใช้มักจะถือว่าช่องสุดท้าย (slot7 ในตัวอย่าง) เป็นช่อง "DebPaid" ซึ่งเป็นจำนวนเงินที่จะชำระหนี้ ในการดำเนินการสินค้าคงคลัง slot7 ไม่มีความเกี่ยวข้อง (จะเป็น 0 เนื่องจากการเคลื่อนย้ายสินค้าคงคลังไม่ได้ชำระหนี้โดยตรง) ในด้านการเงิน เมื่อ StatN ระบุการชำระหนี้หรือบริบทที่เกี่ยวข้อง slot7 จะนำจำนวนเงินที่จ่ายจริงไปเทียบกับยอดคงค้างของลูกค้า ตัวอย่างเช่น หากลูกค้าชำระเงิน 150 ของยอดคงเหลือ 150 นั้นจะปรากฏในช่อง 7 พร้อมด้วย StatN ที่เหมาะสม (2 สำหรับการชำระเงิน) และ StatC (A สำหรับจำนวนเงิน) ไม่ว่ารหัสหรือสถานการณ์จะเปลี่ยนไปอย่างไร เรารู้ว่า slot7 หมายความว่าการชำระหนี้จะเกิดขึ้นหากค่าไม่เป็นศูนย์ภายใต้บริบทของหนี้ ความสอดคล้องนี้ถูกเน้นโดยการสังเกต: ไม่ว่ารหัสจะเปลี่ยนแปลงอย่างไรหรือรวมส่วนลดหรือการซื้อใหม่ใดบ้าง หากมีการชำระหนี้คงค้าง มันจะสะท้อนให้เห็นในช่อง 7 เสมอ แบบจำลองบังคับใช้ตามแบบแผน เพื่อให้ชัดเจนยิ่งขึ้น นี่คือตารางเล็กๆ น้อยๆ ของบทบาทสล็อตในสองบริบท: สล็อต # บทบาทในบริบทสินค้าคงคลัง บทบาทในบริบททางการเงิน ช่องที่ 1–5 รายการสินค้าหรือส่วนประกอบ (เช่น ผลิตภัณฑ์) อาจใช้เพื่อจัดหมวดหมู่ค่าใช้จ่ายหรือแหล่งที่มาของรายได้ แต่โดยทั่วไปจะไม่ส่งผลกระทบโดยตรงต่อผลรวมในตัวเอง (สามารถใช้เป็นป้ายกำกับหรือรายละเอียดย่อยที่รวมกันเป็นยอดรวมได้) ช่องที่ 6 การปรับสินค้าคงคลังหรือจำนวนรายการโบนัส (เช่น ของสมนาคุณ การตัดค่าใช้จ่ายเป็นหน่วย) ส่วนลดหรือจำนวนการปรับ (ถ้ามี) ที่ควรลดยอดรวมทางการเงิน (ในรายการการเงินล้วนๆ ที่ไม่มีการขาย ค่านี้อาจยังคงเป็น 0) ช่องที่ 7 [โดยปกติจะไม่ใช้ในบันทึกสินค้าคงคลัง] – อาจยังคงเป็น 0 หรือบ่งชี้ว่าไม่มีผลกระทบโดยตรงต่อการเคลื่อนย้ายสินค้าคงคลัง การชำระหนี้หรือจำนวนการชำระหนี้ ช่องนี้จะรวบรวมการชำระเงินใดๆ ที่ใช้กับหนี้ ซึ่งมักจะเท่ากับผลรวมที่ชดเชยการขายเครดิตที่บันทึกไว้ก่อนหน้านี้ หากไม่เป็นศูนย์ แสดงว่าเงินที่ได้รับเพื่อล้างลูกหนี้ การใช้ช่องเหล่านี้ทำให้เราสามารถสร้างรายงานได้อย่างง่ายดาย ตัวอย่างเช่น คุณสามารถสรุปยอดขายและการชำระเงินรายวันได้โดยการสแกนรายการทั้งหมดของวันที่ที่กำหนด และเลือกค่าจากช่องที่ระบุ หากเราต้องการ "รายได้ทั้งหมด" เราจะรวมช่องบางช่องจากรายการโดย StatC ระบุจำนวนเงิน และ StatN ระบุยอดขายหรือรายได้ หากเราต้องการ "จำนวนหน่วยที่ขายทั้งหมด" เราจะรวม slot1 ในรายการต่างๆ โดยที่ StatC ระบุจำนวน เนื่องจากช่องอยู่ในตำแหน่งคงที่และมีความหมายที่สอดคล้องกัน สูตรหรือสคริปต์ง่ายๆ จึงสามารถดึงข้อมูลที่ถูกต้องได้ ผลลัพธ์อันทรงพลังประการหนึ่งคือความสามารถในการสร้างสรุปแบบตารางสรุปผลโดยไม่ต้องใช้ตารางสรุปที่ซับซ้อน ข้อมูลได้รับการเปลี่ยนทิศทางไปบ้างแล้วโดยอาศัยการเข้ารหัสหลายส่วนในบรรทัดเดียว เช่น สมมติว่าในวันที่ 2025/03/02 เรามีรายการ OT, Per_dist, 0, B, รถใหม่, รอบร้าน, หน้าร้าน, ค่าน้ำ, อื่นๆ (ดูเหมือนรายการโดยที่ ID1=OT, ID2=Per_dist, StatN=0, StatC=B และ slots คือข้อความ เช่น "รถใหม่", "รอบร้าน" ฯลฯ – อาจเป็นหมวดหมู่ของค่าใช้จ่าย) และรายการอื่นในวันเดียวกัน OT, INC, 0, A, 135124, 0, 0, 0, 0 (บางที ID2=INC ย่อมาจาก “Income”, StatN=0, StatC=A และ slot1=135124 เป็นจำนวนรายได้) เมื่อสร้างรายงาน ระบบสามารถตีความได้ว่า ณ วันนั้น มีชื่อบางประเภท (“รถใหม่” ฯลฯ) เกิดขึ้น (อาจเป็นค่าใช้จ่ายหรือการใช้สินค้าคงคลัง) และบันทึกรายได้ 135,124 รายการ สรุปรายวันสามารถแสดงรายการหมวดหมู่และจำนวนเหล่านั้นได้โดยตรงโดยการอ่านสตริง โดยไม่ต้องเข้าร่วม "ตารางรายได้" และ "ตารางค่าใช้จ่าย" ทั้งหมดรวมอยู่ในรายการเหตุการณ์ที่รวมเป็นหนึ่งเดียว แต่ละบรรทัดเหตุการณ์มีข้อมูลเพียงพอที่จะจัดกลุ่มและสรุปตามตรรกะ ในความเป็นจริง ระบบสามารถตอบคำถามเช่น: “แสดงรายได้รวมและค่าใช้จ่ายรวมในแต่ละวันโดยแยกตามหมวดหมู่” โดยเพียงแค่กรองและรวมค่าช่องภายใต้รหัสที่กำหนด อาจใช้ตรรกะของสูตร เช่น: ผลรวมของค่า slot3 ทั้งหมด โดยที่ ID2 = INC (อาจบ่งบอกถึงรายได้) ในวันที่กำหนด หรือหาก slot3 ถูกกำหนดให้เป็นหมวดหมู่ย่อยเฉพาะในโค้ด ให้ใช้สิ่งนั้น ผลรวมของค่า slot7 โดยที่ StatN=2 (การชำระหนี้) เพื่อดูจำนวนหนี้ที่ชำระในวันนั้น หากรหัสของรายการระบุว่าเป็นเหตุการณ์สินค้าคงคลัง (เช่น ID2 อาจเป็น SK สำหรับหุ้นหรือ PS สำหรับการซื้อหุ้น) เราสามารถตัดสินใจว่าจะไม่รวมข้อมูลเหล่านั้นไว้ในสรุปทางการเงิน (ซึ่งอาจส่งผลต่อระดับสต็อก แต่ไม่ใช่การคำนวณกำไรโดยตรง) ความยืดหยุ่นนั้นน่าทึ่ง: ด้วยการเปลี่ยนแปลงหรือเพิ่มกฎการตีความ เราสามารถสร้างรายงานประเภทใหม่โดยไม่ต้องเปลี่ยนโครงสร้างข้อมูลพื้นฐาน ตัวอย่างเช่น หากเราต้องการติดตามตัวชี้วัดใหม่ เช่น "ยอดขายเฉลี่ยต่อลูกค้า" เราสามารถทำได้โดยการแยกวิเคราะห์สตริงเดียวกันให้แตกต่างกัน (จัดกลุ่มตามรหัสลูกค้า รวมยอดขายจากบางช่อง หารด้วยจำนวนธุรกรรม) เราไม่จำเป็นต้องเพิ่มคอลัมน์ใหม่สำหรับ "ประเภทลูกค้า" หรืออะไรก็ตาม ข้อมูลได้ถูกฝังไว้แล้ว (รหัสลูกค้าเป็นส่วนหนึ่งของ ID1 ฯลฯ) ไม่จำเป็นต้องรวม: เนื่องจากแต่ละรายการมีอยู่ในตัวเอง การรวมข้อมูลมักจะทำได้ง่ายเพียงแค่ซ้อนสตริงเหล่านี้แล้วอ่าน โมเดลนี้ได้รับการอธิบายว่าเป็น "Anti-Normalization Engine" โดยที่มันทำสิ่งที่ตรงกันข้ามกับการทำให้เป็นมาตรฐาน: มันจงใจทำให้เป็นมาตรฐานและบรรจุบริบทในเวลาอินพุต ประโยชน์นี้จะเห็นได้เมื่อวิเคราะห์หรือรายงาน – แทนที่จะเขียนคำสั่งร่วมหรือล้างข้อมูล คุณเพียงสแกนผ่านบันทึกของสตริงที่มีพฤติกรรมหลากหลาย เพื่อเน้นข้อดี ให้พิจารณาข้อดีเหล่านี้ของวิธีเข้ารหัสสล็อต: บริบทบรรทัดเดียว: แต่ละเหตุการณ์เป็นหนึ่งบรรทัดที่บอกเล่าเรื่องราวที่สมบูรณ์ ทำให้ง่ายต่อการต่อท้าย CSV ส่งเป็นข้อความ หรือบันทึกตามลำดับ การตรวจสอบข้อมูลจะคล้ายกับการอ่านบัญชีแยกประเภทหรือแม้แต่บันทึกประจำวันของการดำเนินการ แทนที่จะใช้คีย์อ้างอิงโยงในหลายตาราง ไม่มีการทำให้เป็นมาตรฐานหลังการประมวลผล: เนื่องจากข้อมูลมีมาตรฐานและมีการเข้ารหัส จึงไม่จำเป็นต้องมีขั้นตอนคลังข้อมูลแยกต่างหากเพื่อล้างหรือรวมหมวดหมู่ คุณ "ทำให้เป็นมาตรฐาน" (โครงสร้าง) ที่อินพุตโดยอาศัยตรรกะการเข้ารหัส ดังนั้นคุณจึงไม่ต้องทำให้เป็นมาตรฐานในภายหลัง ไม่มีสถานการณ์ที่ "อ๊ะ เรามีสองรายการที่จริงๆ แล้วหมายถึงสิ่งเดียวกันแต่มีป้ายกำกับต่างกัน มาแก้ไขเรื่องนั้นในโกดังกันเถอะ" รูปแบบการเข้ารหัสควรป้องกันความคลาดเคลื่อนเหล่านั้นล่วงหน้า (หรืออย่างน้อยทำให้ชัดเจนทันที เพื่อให้ผู้ใช้สามารถป้อนข้อมูลได้อย่างถูกต้อง) คอลัมน์ข้อมูลเมตาน้อยลง: สคีมาแบบเดิมอาจมีฟิลด์ Transaction_type, Payment_flag, Category_code ฯลฯ ในที่นี้ คอลัมน์เหล่านี้จะรวมเข้ากับโค้ดและการวางตำแหน่งช่อง ตัวอย่างเช่น คุณไม่จำเป็นต้องมีคอลัมน์ "is_debt_Payment" แบบบูลีน หาก StatN=2 ก็หมายถึงคอลัมน์นั้น คุณไม่จำเป็นต้องมีฟิลด์แยกต่างหากสำหรับ "ปริมาณ" และ "จำนวน" - StatC จะบอกคุณว่าจะถือว่าค่าช่องเป็นปริมาณหรือจำนวนสุดท้าย ข้อมูลทุกชิ้นมีหน้าแรกเดียว (ตำแหน่งเฉพาะในสตริง) ดังนั้นจึงไม่มีการทำซ้ำระหว่างตารางหรือคอลัมน์ โครงสร้างที่ขยายได้: หากพรุ่งนี้ธุรกรรมรูปแบบใหม่จำเป็นต้องมีฟิลด์รายละเอียดเพิ่มเติม คุณสามารถเพิ่มตำแหน่งสล็อตอื่น (เช่น slot8) สำหรับรายละเอียดนั้น โดยไม่ทำลายรายการที่มีอยู่ รายการที่เก่ากว่าอาจไม่ใช้ slot8 (โดยปริยายจะมี 0 หรือว่างเปล่า) สิ่งนี้ก่อกวนน้อยกว่าการแก้ไขตารางฐานข้อมูลเพื่อเพิ่มคอลัมน์ใหม่ (ซึ่งอาจต้องมีการทดแทนหรือเป็นโมฆะและแก้ไขแบบสอบถาม) ในโมเดลของเรา การเพิ่มช่องเป็นเหมือนการอัปเดตกฎการแยกวิเคราะห์ ระบบยังคงใช้งานร่วมกันได้แบบย้อนหลัง ตราบใดที่รู้ว่าหากรายการไม่มี slot8 รายละเอียดนั้นจะไม่สามารถใช้ได้ โดยพื้นฐานแล้ว คุณมีสคีมาแบบไดนามิกแต่เข้ากันได้แบบย้อนหลัง มนุษย์สามารถอ่านได้ เป็นมิตรกับเครื่องจักร: เมื่อมองแวบแรก บางอย่างเช่น SH11-CR-1-A-0-0-0-0-0-1000 (เป็นสตริงตัวอย่าง) อาจดูเป็นความลับ แต่ด้วยการฝึกอบรมเพียงเล็กน้อย ผู้ใช้สามารถอ่านได้: SH11 ทำ CR โดยมีผลลัพธ์เป็น 1,000 แน่นอนว่าสามารถอ่านได้มากกว่า JSON แบบดิบหรือชุด ID ที่ทำให้เป็นมาตรฐาน และสำหรับเครื่องจักร การแยกวิเคราะห์นั้นง่ายมาก (แยกตามตัวคั่นและคุณจะรู้ได้อย่างชัดเจนว่าดัชนีใดคือดัชนีใด) รูปแบบที่กำหนดขึ้นช่วยให้มีการนำไปใช้อย่างรวดเร็วในเครื่องมือต่างๆ เช่น Excel (ซึ่งคุณสามารถแปลงข้อความเป็นคอลัมน์หรือใช้สูตรเพื่อเลือกส่วนที่ n) หรือ Python (แยกสตริงและดำเนินการ) หรือ SQL (คุณยังสามารถจัดเก็บสตริงทั้งหมดและใช้สตริงย่อยหรือฟังก์ชันสตริงในตัวเพื่อแยกชิ้นส่วนได้หากจำเป็น) ดังนั้น โมเดลจึงมีความสมดุล โดยมีโครงสร้างเพียงพอสำหรับเครื่องจักร แต่ไม่เป็นนามธรรมจนมนุษย์ไม่สามารถตีความได้ ซึ่งจะช่วยลดอุปสรรคในการตรวจสอบและการตรวจสอบข้อมูลด้วยตนเอง ในทางปฏิบัติ ผู้ใช้ระบบนี้พบว่าพวกเขาสามารถรักษาตารางหลักได้เพียงตารางเดียว (หรือแม้แต่ไฟล์ CSV) ของธุรกรรมทั้งหมด ต้องการรายงานบางอย่างหรือไม่? พวกเขาสามารถกรองตารางนั้นตามเงื่อนไขของรหัสหรือค่าช่อง ต้องการทำงานร่วมกับระบบอื่นหรือไม่? พวกเขาสามารถส่งสายเหล่านี้ได้และฝ่ายรับเมื่อรู้รูปแบบก็สามารถดำเนินการตามนั้นได้ มันเหมือนกับว่าแต่ละรายการมีสัญญา API ขนาดเล็กที่บ่งบอกความหมาย แอปพลิเคชันแบบ Flow-Based ใน CRM และการเงิน แรงจูงใจประการหนึ่งสำหรับโมเดลนี้คือการจัดการ CRM (การจัดการลูกค้าสัมพันธ์) และการติดตามทางการเงินในบริบทของธุรกิจขนาดเล็กได้ดีขึ้น ระบบ CRM/ERP แบบดั้งเดิมมักจะแยกข้อมูลออกไป เช่น การขายในโมดูลหนึ่ง การชำระเงินในอีกโมดูลหนึ่ง สินค้าคงคลังในอีกโมดูลหนึ่ง ในทางตรงกันข้าม วิธีการนี้ช่วยให้สามารถบันทึกเหตุการณ์ที่เกี่ยวข้องทั้งหมดได้ในลำดับเดียว จากนั้นจึงแบ่งข้อมูลนั้นตามต้องการ พิจารณาสถานการณ์จำลองของธุรกิจการค้าขนาดเล็ก พวกเขามีลูกค้าที่ซื้อสินค้า (บางครั้งก็เป็นเครดิต บางครั้งก็เป็นเงินสด) พวกเขามีสินค้าคงคลังเข้าและออก และพวกเขาก็มีค่าใช้จ่ายต่างๆ (ค่าจ้าง ค่าสาธารณูปโภค ฯลฯ) โมเดลสล็อต persona–action ช่วยให้เราสามารถเข้ารหัสเหตุการณ์ที่แตกต่างกันเหล่านี้ทั้งหมดในสตรีมเดียว: การขายเงินสดให้กับลูกค้าจะเป็นรายการเดียว (ลักษณะลูกค้า + การดำเนินการ "ซื้อ" เงินสด StatN 0 จำนวน StatC B พร้อมด้วยปริมาณและหมวดหมู่สินค้าในช่อง) การขายเครดิตให้กับลูกค้า (ลูกค้า + การดำเนินการ "ซื้อ", StatN 1 สำหรับเครดิต, StatC B โดยอาจมีช่องปริมาณและราคา) การชำระเงินจากลูกค้ารายนั้นในภายหลัง (ลูกค้า + การดำเนินการ "ชำระคืน", StatN 2, StatC A พร้อมจำนวนเงินในช่อง 7) การรับสินค้าคงคลังจากซัพพลายเออร์ (บุคคลซัพพลายเออร์ + การดำเนินการ "อุปทาน" StatN 3 อาจหมายถึงการโอนหรือเพียง 0 หากถือเป็นการซื้อเงินสด รายการสล็อตที่ได้รับ) การจ่ายค่าจ้างให้กับพนักงาน (ลักษณะพนักงาน + การดำเนินการ "จ่าย" อาจเป็น StatN 0 ถ้าเป็นเงินสด StatC A ที่มีจำนวนเงิน หรือ StatC B ถ้าชั่วโมงถูกกำหนดในช่องเพื่อคูณด้วยอัตราค่าจ้าง) ค่าใช้จ่ายเบ็ดเตล็ด เช่น สาธารณูปโภค (บุคคลอาจเป็นหมวดหมู่ เช่น "ค่าใช้จ่าย" หรือแผนก การดำเนินการ "PAY" เงินสด StatN 0 StatC A พร้อมจำนวนเงิน และช่องที่ใช้จัดหมวดหมู่ประเภทค่าใช้จ่าย) ทั้งหมดนี้สามารถอยู่ในตารางเดียว โดยแยกความแตกต่างตามรหัสบุคคลและรหัสการดำเนินการ หากต้องการรับบัญชีแยกประเภทลูกค้า จะมีการกรองตามรหัสของลูกค้ารายนั้น ในการรับงบกำไรขาดทุน ตัวกรองหนึ่งจะกรองตามรหัสการดำเนินการบางอย่าง (การดำเนินการขายเทียบกับการดำเนินการด้านค่าใช้จ่าย) และรวมช่องที่เหมาะสม (รายได้อาจอยู่ในค่าช่องสำหรับการขาย ค่าใช้จ่ายในช่องสำหรับการดำเนินการด้านค่าใช้จ่าย) หากต้องการรับรายงานสินค้าคงคลัง ให้กรองตามการดำเนินการที่เกี่ยวข้องกับสินค้าคงคลัง (สต็อกเข้าและสต็อกออก) และจำนวนช่องรวม ตัวอย่างที่เป็นรูปธรรม: สรุปกระแสการเงินรายวัน ด้วยการใช้ข้อมูลที่เข้ารหัสของเรา เราสามารถสร้างรายงานโฟลว์รายวันที่แสดงในแต่ละวัน จำนวนเงินสดเข้า จำนวนเครดิตที่ขยายออกไป จำนวนเงินสดที่จ่ายไป ฯลฯ โดยไม่ต้องออกแบบรายงานแยกกันสำหรับแต่ละด้าน เราเพียงกำหนดตรรกะเพื่อตีความสตริง: ถ้า StatN=0 (เงินสด) และ StatC=A (จำนวนเงิน) ให้เพิ่มลงในผลรวมการรับเงินสดรายวัน (หากเป็นการดำเนินการรายได้) หรือผลรวมค่าใช้จ่ายเงินสด (หากเป็นการดำเนินการค่าใช้จ่ายหรือการดำเนินการชำระเงิน) ถ้า StatN=1 (เครดิต) และ StatC=A ให้เพิ่มไปยังบัญชีลูกหนี้ (การขายที่ทำโดยใช้เครดิต) ถ้า StatN=2 (การชำระหนี้) ให้เพิ่มจำนวนเงินนั้นในใบเสร็จรับเงิน (เงินที่ได้รับ) และลดลูกหนี้ หาก StatN=0 และ StatC=B มีสล็อต นั่นหมายถึงการขายเป็นหน่วย เราอาจคูณหน่วยเหล่านั้นด้วยราคาเพื่อคำนวณรายได้ หรือถ้าเรามีรายการคู่ขนานที่ให้ผลลัพธ์จากค่าที่คำนวณ เราอาจใช้ค่านั้นโดยตรง ในกรณีการใช้งานจริงครั้งหนึ่ง ระบบสามารถแสดงความสามารถในการทำกำไรรายวันแบบเรียลไทม์โดยการอ่านสตริงเหล่านี้ มีชิ้นส่วนที่จำเป็นทั้งหมด: รายได้จากการขายเงินสด รายได้จากการขายเครดิต ต้นทุนสินค้า (หากเข้ารหัสในรายการอื่นหรืออาจเป็นค่าลบในช่องสำหรับการใช้สินค้าคงคลัง) ค่าใช้จ่ายจากหมวดหมู่ต่างๆ ฯลฯ ตรรกะสรุปอาจกล่าวได้ว่า: "รวมรายการทั้งหมดในวันที่ X โดยที่ ID2 ระบุหมวดหมู่รายได้เพื่อรับรายได้รวม ผลรวมทั้งหมดที่ ID2 ระบุค่าใช้จ่ายเพื่อรับค่าใช้จ่ายทั้งหมด นอกจากนี้ ให้พิจารณาเครดิตที่ได้รับ (ซึ่งก็คือรายได้ แต่ไม่ใช่เงินสด) และเครดิตที่ชำระคืน (ซึ่งเพิ่มเงินสด)” กฎเหล่านี้ถูกนำมาใช้โดยมีเงื่อนไขง่ายๆ ในฟิลด์ที่เข้ารหัส สิ่งที่สำคัญที่สุดคือการบรรลุเป้าหมายนี้ ไม่จำเป็นต้องมีตารางการขาย ลูกหนี้ การชำระเงิน ฯลฯ แยกกัน จากนั้นจึงรวม ETL เข้าด้วยกัน เนื่องจากข้อมูลถูกป้อนเข้าด้วยตรรกะแบบรวม การคำนวณผ่านครั้งเดียวจึงสามารถรับยอดคงเหลือได้ วิธีการนี้ถือว่าบัญชีแยกประเภทเป็นสตรีมเหตุการณ์เป็นหลัก (เหมือนกับการจัดหาเหตุการณ์ในสถาปัตยกรรมซอฟต์แวร์สมัยใหม่): แต่ละสตริงคือเหตุการณ์ และคุณสามารถพับ/ลดเหตุการณ์เหล่านั้นเพื่อสร้างผลรวมใดๆ ได้ อันที่จริง โมเดลดังกล่าวสอดคล้องกับกรอบความคิดของสตรีมเหตุการณ์ได้เป็นอย่างดี เราสามารถป้อนรายการเหล่านี้ลงในตัวประมวลผลสตรีม (เช่น Kafka) และให้ผู้บริโภคที่แตกต่างกันคำนวณมุมมองที่แตกต่างกัน (รายการหนึ่งสำหรับระดับสินค้าคงคลัง หนึ่งรายการสำหรับงบการเงิน หนึ่งรายการสำหรับการสรุปลูกค้า CRM) ทั้งหมดนี้มาจากบันทึกเหตุการณ์แบบรวมเดียวกัน จากมุมมองของ CRM ทุกปฏิสัมพันธ์ของลูกค้าจะถูกบันทึกในรูปแบบเดียวกัน ไม่ว่าจะเป็นการขาย การคืนสินค้า การชำระเงิน หรือการปรับวงเงินเครดิต นี่เป็นการแสดงไทม์ไลน์พฤติกรรมต่อลูกค้าหนึ่งราย CRM แบบดั้งเดิมอาจติดตามการโต้ตอบในบันทึกย่อและแยกธุรกรรมทางการเงินในบัญชีแยกประเภท ที่นี่ขอบเขตไม่ชัดเจน การโต้ตอบอาจเป็นเหตุการณ์บัญชีแยกประเภทและในทางกลับกัน เป็นมุมมองพฤติกรรมที่บูรณาการอย่างแท้จริง: คุณจะเห็นว่าลูกค้า X ซื้อบางสิ่งบางอย่าง จากนั้นชำระเงินในภายหลัง แล้วซื้ออีกครั้ง ฯลฯ เพียงแค่อ่านลำดับเหตุการณ์ที่เข้ารหัสของพวกเขา ประโยชน์ที่จับต้องได้ประการหนึ่งที่สังเกตได้คือการกรองบริบทอัตโนมัติ ตัวอย่างเช่น ธุรกรรมสินค้าคงคลังโดยธรรมชาติจะไม่แสดงในสรุปทางการเงิน เนื่องจากรหัสและช่องไม่ตรงตามเกณฑ์สำหรับสรุปเหล่านั้น ไม่จำเป็นต้องมีแฟล็กพิเศษ เช่น "exclude_from_financials" ซึ่งก็มีอยู่แล้ว เฉพาะรายการที่มีการรวม StatN/StatC ทางการเงินเท่านั้นที่จะนำไปใช้ในการคำนวณทางการเงิน การเคลื่อนย้ายสินค้าคงคลังอย่างแท้จริง (เช่น การโอนย้ายสินค้าคงคลังระหว่างคลังสินค้า หากเข้ารหัสอย่างเหมาะสม) อาจมี StatN อาจเป็นรหัสพิเศษที่ตรรกะสรุปทางการเงินละเว้น ด้วยวิธีนี้ บันทึกแบบรวมหนึ่งรายการจะทำหน้าที่ได้หลายวัตถุประสงค์โดยไม่มีการรบกวน มันคือทั้งหมดที่เกี่ยวกับการออกแบบโค้ดเหล่านั้นอย่างชาญฉลาด จากนั้นปล่อยให้ตรรกะของโค้ดขับเคลื่อนการรวม/การแยกออกในการคำนวณต่างๆ กล่าวโดยสรุปก็คือ โมเดลสล็อต persona–action ทำให้ข้อมูลมีพฤติกรรม แทนที่จะบันทึกแบบคงที่ที่รอการประมวลผล ระเบียนจะนำกระบวนการติดตัวไปด้วย สิ่งนี้จะเปลี่ยน CRM หรือระบบบัญชีจากฐานข้อมูลแบบคงที่ให้กลายเป็นสิ่งที่คล้ายกับการจำลองหรือแบบจำลองของธุรกิจ โดยที่แต่ละรายการจะกระตุ้นให้เกิดผลลัพธ์ที่เหมาะสม (อัปเดตสินค้าคงคลัง อัปเดตยอดคงเหลือ ฯลฯ) โดยทันทีตามเนื้อหา การใช้งานและบูรณาการเครื่องมือที่ไม่เชื่อเรื่องพระเจ้า ลักษณะที่น่าตื่นเต้นของโมเดลนี้คือ เป็นแบบไม่เชื่อเรื่องพระเจ้าตามแพลตฟอร์ม เนื่องจากแต่ละรายการโดยพื้นฐานแล้วเป็นบรรทัดข้อความที่คั่นด้วยเครื่องหมายจุลภาคและมีโครงสร้างโดยธรรมชาติ ดังนั้นจึงสามารถจัดการได้โดยเครื่องมือใดๆ ก็ตามที่จัดการข้อความหรือตาราง เราพบว่าแนวทางนี้ช่วยเพิ่มศักยภาพให้กับทุกเครื่องมือ แทนที่จะขึ้นอยู่กับเครื่องมือใดเครื่องมือหนึ่ง ต่อไปนี้คือลักษณะการทำงานของเทคโนโลยีต่างๆ: ซอฟต์แวร์ Excel หรือสเปรดชีต: สามารถโหลด CSV ของรายการเหล่านี้ลงใน Excel หรือ Google ชีตได้ ด้วยความรู้ที่ถูกต้องเกี่ยวกับรูปแบบ เราสามารถใช้สูตรในการแยกส่วนต่างๆ ได้ ตัวอย่างเช่น การใช้ฟังก์ชัน TEXTBEFORE และ TEXTAFTER หรือ SPLIT ของ Excel (ใน Google ชีต) เพื่อรับค่าช่องที่แน่นอน เนื่องจากแต่ละชิ้นอยู่ในตำแหน่งที่คาดเดาได้ แม้แต่ผู้ที่ไม่ใช่โปรแกรมเมอร์ก็สามารถตั้งค่าการสรุปได้ สามารถเขียน =SUMIFS(Table[slot3], Table[ID2], "INC", Table[Date], ">=2025-02-01", Table[Date], "<=2025-02-29") เพื่อรวม slot3 สำหรับรายการทั้งหมดที่การกระทำ (ID2) คือ “INC” (อาจระบุหมวดหมู่รายได้) ภายในเดือนกุมภาพันธ์ 2025 นี่เป็นเพียงตัวอย่าง ประเด็นหลักคือ Excel สามารถกรองและรวมตามเงื่อนไขโดยตรงกับข้อมูลที่เข้ารหัส ดำเนินการเดือยหรือรายงานได้อย่างมีประสิทธิภาพโดยไม่ต้องเข้าร่วมหรือมาโครเดียว ข้อมูลได้รับการออกแบบมาให้รวบรวมได้ง่าย (เพราะสิ่งที่คล้ายกันใช้ ID หรือรูปแบบสล็อตร่วมกัน) ฐานข้อมูล SQL: หากจัดเก็บรายการเหล่านี้ในฐานข้อมูล SQL (แม้จะเป็นตารางขนาดใหญ่ตารางเดียวที่มีคอลัมน์สำหรับแต่ละส่วน หรือเพียงคอลัมน์หยดข้อความ) เราก็ยังสามารถใช้ประโยชน์จากการสืบค้นได้ SQL สมัยใหม่ช่วยให้ฟังก์ชันสตริงหรือแม้แต่ regex สามารถแยกส่วนต่างๆ ได้ อีกทางหนึ่งอาจจัดเก็บด้วยวิธีที่ทำให้เป็นมาตรฐาน (แต่ละส่วนในคอลัมน์: วันที่, ID1, ID2, StatN, StatC, slot1...slotN เป็นคอลัมน์) ที่น่าสนใจคือ ถ้าคุณทำเช่นนั้น คุณจะมีตารางที่ทำให้เป็นมาตรฐานโดยสมบูรณ์ แต่ไม่จำเป็นต้องใช้ตารางอื่นที่เกี่ยวข้อง กุญแจต่างประเทศหมดเพราะเราอินไลน์ไว้ ดังนั้นคุณจึงสามารถจัดทำดัชนีตาม ID1, ID2 ฯลฯ และสืบค้นได้อย่างรวดเร็ว แต่คุณไม่จำเป็นต้องทำเช่นนี้ เนื่องจากการวิเคราะห์ส่วนใหญ่สามารถทำได้โดยการสแกนตามลำดับ เราได้เปลี่ยนความซับซ้อนโดยพื้นฐานแล้ว ซึ่งไม่ได้อยู่ในการออกแบบสคีมา แต่อยู่ในตรรกะการตีความ (ซึ่งเปลี่ยนแปลงได้ง่ายกว่า) SQL กลายเป็นเพียงเครื่องมือจัดเก็บข้อมูลที่นี่ การยกความหมายหนักๆ นั้นทำได้โดยรูปแบบข้อมูลนั่นเอง Python หรือสคริปต์อื่นๆ: การเขียน parser สำหรับสตริงเหล่านี้ใน Python นั้นตรงไปตรงมา: แบ่งด้วยเครื่องหมายจุลภาคและแมปฟิลด์ให้กับตัวแปร จากนั้นเราสามารถใช้กฎได้ (อาจเป็นพจนานุกรมของคอมโบ StatN/StatC กับพฤติกรรม) ตัวอย่างเช่น สคริปต์ Python สามารถอ่านแต่ละบรรทัดได้ และถ้า entry.StatN == 0 และ entry.StatC == "B" ให้ทำสิ่งหนึ่ง (อาจคูณค่า slot) ถ้า StatC == "A" เพียงแค่รับค่า เป็นต้น ซึ่งสามารถสร้างพจนานุกรมของผลลัพธ์ในแต่ละวันหรือแต่ละบุคคลได้ เนื่องจากตรรกะถูกฝังไว้ รหัสในการจัดการจึงสามารถเป็นแบบทั่วไปได้ โดยไม่จำเป็นต้องรู้เกี่ยวกับผลิตภัณฑ์เฉพาะบางรายการหรือประเภทค่าใช้จ่ายเฉพาะทุกประเภท เพียงทำตามรหัสเท่านั้น ตัวแยกวิเคราะห์จำนวนมากอาจเป็นแบบโอเพ่นซอร์สเป็นไลบรารีแบบไลท์เวท โดยที่ชุดกฎสามารถกำหนดค่าได้ (ลองจินตนาการถึงไฟล์กำหนดค่าที่กำหนดว่า StatN และ StatC แต่ละตัวมีความหมายอย่างไรสำหรับคู่การกระทำแบบบุคคลที่กำหนด ซึ่งตัวแยกวิเคราะห์จะใช้) สิ่งนี้จะช่วยให้ผู้อื่นสามารถนำโมเดลที่คล้ายกันมาใช้กับข้อมูลของตนได้ API และการแลกเปลี่ยน: หากทั้งสองระบบต้องการสื่อสาร พวกเขาสามารถส่งสตริงเหล่านี้กลับไปกลับมาเป็นเพย์โหลด มนุษย์สามารถอ่านได้มากพอที่จะแก้ไขข้อบกพร่องหากมีสิ่งผิดปกติเกิดขึ้น แต่ยังกระชับและมีโครงสร้างสำหรับการแยกวิเคราะห์เครื่อง ตัวอย่างเช่น ตำแหน่งข้อมูล API สามารถยอมรับสตริงเช่น {"transaction": "SH01,BY,0,B,5,0,0,0"} ใน JSON ผู้รับจะแยกด้วยเครื่องหมายจุลภาคและรู้ว่าต้องทำอย่างไร ในทางตรงกันข้าม API แบบดั้งเดิมอาจต้องการโครงสร้าง JSON ที่ซับซ้อนซึ่งมีฟิลด์ที่ซ้อนกันสำหรับ ID ลูกค้า รายการสินค้า ประเภทการชำระเงิน ฯลฯ ซึ่งมีรายละเอียดมากกว่าและยังคำนึงถึงเวอร์ชันด้วย วิธีการแบบสตริงเดี่ยวของเรา หากขยายหรือแก้ไข โดยปกติแล้วยังสามารถแยกวิเคราะห์ตามเวอร์ชันเก่าได้ พวกเขาอาจเพิกเฉยต่อช่องพิเศษที่พวกเขาไม่เข้าใจ แต่จะไม่พังทั้งหมด ทำให้การบูรณาการมีความยืดหยุ่นต่อการเปลี่ยนแปลงมากขึ้น การเชื่อมต่อกับมนุษย์: อาจสร้างเลเยอร์ส่วนติดต่อผู้ใช้แบบธรรมดาไว้ด้านบนของโมเดลนี้ ตัวอย่างเช่น เว็บฟอร์มที่มีดรอปดาวน์และช่องป้อนข้อมูลสำหรับการขายสามารถเขียนสตริงภายในและบันทึกได้ ในทางกลับกัน UI สามารถใช้สตริงและถอดรหัสเพื่อแสดงคำอธิบายที่เป็นมิตร (“ลูกค้า SH01 ซื้อ 5 หน่วยด้วยเงินสด”) ตรรกะ UI ประเภทนี้สามารถสร้างได้เพียงครั้งเดียวและนำกลับมาใช้ใหม่ได้ (เนื่องจากรูปแบบข้อมูลมีความสม่ำเสมอ) “วิซาร์ดสตริงตรรกะ” ก็มีศักยภาพเช่นกัน ซึ่งเป็นเครื่องมือที่ช่วยให้ผู้ใช้สร้างหรือแยกโครงสร้างของสตริงเหล่านี้โดยแนะนำพวกเขาผ่านส่วนต่างๆ (รับรองความถูกต้องและเสนอตัวเลือกสำหรับบุคคลและการกระทำ ฯลฯ) ซึ่งจะช่วยให้พนักงานที่ไม่เชี่ยวชาญด้านเทคนิคสามารถใช้ประโยชน์จากประสิทธิภาพของโมเดลได้โดยไม่ต้องพิมพ์โค้ดด้วยตนเอง ในขณะที่ยังคงจัดเก็บข้อมูลในรูปแบบที่เป็นหนึ่งเดียว ธีมหลักคือการทำงานร่วมกัน การไม่ผูกโมเดลกับซอฟต์แวร์ใดๆ จะทำให้ข้อมูลเป็นอิสระ ข้อมูลสามารถอยู่ในไฟล์ข้อความ แผ่นงาน Excel ฐานข้อมูล หรือทั้งหมดพร้อมกันได้โดยไม่มีความไม่สอดคล้องกัน ผู้มีส่วนได้ส่วนเสียต่างๆ สามารถโต้ตอบกับสิ่งนี้ได้ในเครื่องมือที่ตนเลือก - นักบัญชีอาจใช้ตารางเดือย Excel, นักวิเคราะห์ข้อมูลอาจใช้ Python, ผู้จัดการอาจชอบแดชบอร์ดเว็บแบบกำหนดเอง - ทั้งหมดนี้ดึงมาจากชุดข้อมูลที่เข้ารหัสเดียวกัน สิ่งนี้ไม่ค่อยราบรื่นนักกับระบบทั่วไป โดยที่คุณมักจะต้องส่งออก/นำเข้าหรือรักษาการแสดงข้อมูลหลายรายการ (เสี่ยงต่อการล้าสมัย) ที่นี่ตัวแทนเดียวทำหน้าที่ได้ทั้งหมด เป็นที่น่าสังเกตว่าในตอนแรกผู้ใช้บางคนต่อต้านแนวคิดเรื่องการเข้ารหัสดังกล่าว โดยกลัวว่ามันจะเป็น "ระดับต่ำ" เกินไป แต่เมื่อพวกเขาเห็นว่ามันทำให้ระบบนิเวศโดยรวมง่ายขึ้น (ตารางน้อยลง, สคริปต์ ETL น้อยลง, ฟิลด์ที่คลุมเครือน้อยลง) พวกเขาก็ชื่นชมว่าแต่ละเครื่องมือสามารถเล่นได้ดี เราเปลี่ยนความซับซ้อนจากการบูรณาการไปสู่การตีความได้อย่างมีประสิทธิภาพ การบูรณาการกลายเป็นเรื่องเล็กน้อย (เพียงแค่แชร์สตริง) การตีความต้องอาศัยความเข้าใจในตรรกะ แต่ตรรกะนั้นมีความสอดคล้องและบันทึกไว้ในที่เดียว (คำจำกัดความของโค้ด) แทนที่จะกระจัดกระจายไปตามรายงานและการรวมจำนวนมาก กระตุ้น AI และสอดคล้องกับความคิดของมนุษย์ การพัฒนาและปรับปรุงโมเดลนี้เป็นกระบวนการที่ต้องทำซ้ำๆ และที่น่าสนใจคือ AI (โดยเฉพาะโมเดลการสนทนา เช่น ChatGPT) มีบทบาทในการทดสอบและท้าทายตรรกะ การใช้ AI ในลูปให้ข้อมูลเชิงลึกทั้งในด้านการปรับปรุงโมเดลและสร้างความมั่นใจว่าระบบอัจฉริยะจะสอดคล้องกับโมเดลดังกล่าว ในส่วนนี้จะแชร์กลยุทธ์บางอย่างที่ใช้ในการกระตุ้นโมเดลและวิธีพิจารณาการจัดตำแหน่ง AI ในการออกแบบ: การปรับแต่งการสนทนา: ผู้สร้างโมเดลนี้มักจะมีส่วนร่วมในการสนทนากับ ChatGPT ไม่ใช่แค่เพื่อให้ได้คำตอบโดยตรง แต่เพื่อดูว่าโมเดลนั้นสมเหตุสมผลนอกความคิดของตนเองหรือไม่ ด้วยการอธิบายแนวคิดให้ AI และสังเกตการตีความ ทำให้พวกเขาระบุความเข้าใจผิดได้ ทุกครั้งที่ AI ทำผิดหรือสับสน มันจะส่งสัญญาณว่าส่วนหนึ่งของโมเดลจำเป็นต้องมีการชี้แจงหรือปรับแต่ง ตัวอย่างเช่น ในช่วงแรก ๆ ของ AI อาจวาดแผนภาพที่ไม่ถูกต้องเกี่ยวกับการไหลของข้อมูล นี่แสดงว่าคำอธิบายหรือโครงสร้างที่ให้มานั้นคลุมเครือ ด้วยการแก้ไข AI ผู้สร้างจึงได้ชี้แจงโมเดลไปพร้อมๆ กัน การลองผิดลองถูกนี้คล้ายกับการแก้ไขจุดบกพร่องของเป็ดยาง แต่มีเป็ดอัจฉริยะที่พยายามเสนอแนวคิดของตัวเอง กระบวนการนี้เปิดเผยช่องว่างและกระตุ้นให้นักประดิษฐ์กระชับคำจำกัดความ (เช่น เสริมว่า “Slot7 แสดงถึงการชำระหนี้ในบริบททางการเงินเสมอ” เมื่อ AI พลาดความแตกต่างเล็กน้อยนั้นในตอนแรก) การแจ้งเตือนสำหรับกรณี Edge: เทคนิคการแจ้งเตือนที่ชาญฉลาดอย่างหนึ่งคือการขอให้ AI มี "เนื้อหาที่มีน้ำหนักน้อย" หรือแนวคิดที่ไม่คาดคิด โดยพื้นฐานแล้วเป็นการกระตุ้นให้ AI สร้างความคิดที่ผู้ใช้อาจไม่คาดคิดหรือต้องการด้วยซ้ำ นี่เป็นวิธีหนึ่งในการแสดงมุมมองที่แปลกใหม่หรือข้อผิดพลาดที่อาจเกิดขึ้น ตัวอย่างเช่น AI อาจแสดงข้อความว่า “จะเกิดอะไรขึ้นถ้ามีคนป้อนสตริงที่มีรูปแบบไม่ถูกต้องเราจะจัดการกับข้อผิดพลาดได้อย่างไร” หรือ “แนวทางนี้สามารถอคติต่อ AI หรือความคิดของผู้ใช้ในทางใดทางหนึ่งได้หรือไม่” ด้วยการเชิญ AI อย่างชัดเจนให้นำเสนอเนื้อหาที่ "นอกประเด็นหรือไม่พึงประสงค์" ผู้ใช้ได้รับการวิพากษ์วิจารณ์จากผู้สนับสนุนของปีศาจ สิ่งนี้เผยให้เห็นถึงความจำเป็นในการพิจารณาการจัดการข้อผิดพลาด (สตริงที่มีรูปแบบไม่ถูกต้อง หรือจะเกิดอะไรขึ้นหากมีคนไม่ปฏิบัติตามกฎการเข้ารหัสอย่างเคร่งครัด) นอกจากนี้ยังเน้นย้ำถึงอคติ: ผู้ใช้เน้นที่ตรรกะเป็นอย่างมาก ซึ่งอาจเป็นผลเสียต่อผู้ที่คิดแบบเห็นภาพมากกว่า AI ชี้ให้เห็นว่าผู้ใช้บางคนอาจชอบอินเทอร์เฟซแบบภาพมากกว่า และแม้ว่าสตริงตรรกะจะมีประสิทธิภาพ แต่การฝึกอบรมพนักงานที่ไม่ใช่ด้านเทคนิคอาจเป็นเรื่องท้าทาย ข้อมูลเชิงลึกเหล่านี้นำไปสู่แนวคิดต่างๆ เช่น การสร้าง UI ที่ใช้งานง่ายที่ด้านบนของสตริง (ดังที่ได้กล่าวไว้ก่อนหน้านี้) และรับรองกลไกการตรวจสอบความถูกต้องสำหรับอินพุต การปรับความเข้าใจ AI: มีความพยายามอย่างมีสติในการปรับวิธีการให้เหตุผลของ AI ให้สอดคล้องกับโครงสร้างของแบบจำลอง นึกถึงการสนทนาก่อนหน้านี้เกี่ยวกับการหลีกเลี่ยง SVO สามเท่าเต็มรูปแบบเพื่อป้องกันความสับสนของ AI นี่คือรูปแบบหนึ่งของการจัดตำแหน่ง AI ซึ่งเป็นการจัดโครงสร้างข้อมูลเพื่อให้สอดคล้องกับวิธีที่ AI (หรือระบบอัจฉริยะในอนาคต) สามารถประมวลผลข้อมูลได้โดยไม่ต้องตีความผิด ด้วยการลดความกำกวมทางความหมาย (โดยใช้ตำแหน่งคงที่และค่าที่เข้ารหัสแทนข้อความอิสระ) โมเดลนี้ทำให้มั่นใจได้ว่าตัวแทน AI สามารถแยกวิเคราะห์และดำเนินการกับมันได้อย่างน่าเชื่อถือ ในการทดสอบ เมื่อ ChatGPT "เข้าใจ" รูปแบบโค้ด (ID1, ID2, StatN, StatC, slot) แล้ว ChatGPT ก็สามารถติดตามพร้อมกับคำถามของผู้ใช้เกี่ยวกับมัน และยังช่วยคำนวณผลลัพธ์หรือค้นหารูปแบบอีกด้วย โดยพื้นฐานแล้ว รูปแบบข้อมูลได้รับการออกแบบไม่เพียงแต่สำหรับการใช้งานเครื่องจักรเท่านั้น แต่ยังเพื่อการให้เหตุผลของเครื่องอย่างชาญฉลาดอีกด้วย AI อาจได้รับแจ้งให้ปฏิบัติต่อแต่ละรายการเสมือนเป็นคำสั่งการเขียนโปรแกรมประเภทหนึ่ง (เช่น “ถ้า StatN=2 และ StatC=A ให้ลบ slot7 ออกจากบัญชีแยกประเภทหนี้ของลูกค้ารายนั้น”) ซึ่งเป็นงานที่ทำง่ายกว่าด้วยโค้ดที่มีโครงสร้างมากกว่าประโยคธรรมดา การแจ้งตามบุคคล: กลยุทธ์การกระตุ้นอีกวิธีหนึ่งที่ใช้คือการให้ AI มีบุคคลหรือบทบาทในการสนทนาเพื่อเน้นไปที่การสนทนา ตัวอย่างเช่น “ลองนึกภาพคุณเป็นนักวิเคราะห์ข้อมูลที่พยายามทำความเข้าใจโมเดลข้อมูลใหม่นี้…” สิ่งนี้ทำให้ AI มีความสำคัญมากขึ้นและเน้นรายละเอียดในการประเมินระบบมากขึ้น มันจะก้าวผ่านตรรกะในลักษณะลูกโซ่แห่งความคิด ซึ่งบางครั้งก็ปรากฏประเด็นที่ละเอียดอ่อน สถานการณ์หนึ่งกระตุ้นให้ AI ทำหน้าที่เป็นวิศวกรฐานข้อมูลที่น่าสงสัย ซึ่งทำให้ AI ต้องย่างโมเดลบนทฤษฎีการทำให้เป็นมาตรฐาน หรือในฐานะเจ้าของธุรกิจ ซึ่งทำให้ AI ถามคำถามการใช้งานจริง (“ ฉันจะแก้ไขข้อผิดพลาดในรายการสตริงได้อย่างไร” ฯลฯ ) ด้วยการสวมบทบาทตามคำสั่ง ผู้สร้างทำให้มั่นใจได้ว่าแบบจำลองได้รับการตรวจสอบจากหลายมุม การวัดความสอดคล้องกับตรรกะของมนุษย์: นอกจากนี้ AI ยังใช้เพื่อระบุความแตกต่างระหว่างแนวทางนี้กับระบบแบบดั้งเดิมในภาษาธรรมดา ซึ่งทำหน้าที่เป็นกระจกสะท้อนให้เห็นว่าคนทั่วไปมองเห็นได้อย่างไร ในการแลกเปลี่ยนครั้งหนึ่ง AI ได้สรุปปรัชญาของโมเดลว่า "การแทนที่สคีมาด้วยไวยากรณ์เชิงพฤติกรรม" และกล่าวถึง "การบีบอัดความหมาย" ที่เกิดขึ้นจากสตริงที่มีขนาดกะทัดรัด วลีเหล่านี้สร้างขึ้นโดย AI ช่วยให้ผู้สร้างสามารถระบุผลประโยชน์ได้ชัดเจนยิ่งขึ้นในแง่ของมนุษย์ เป็นการยืนยันว่า AI เข้าใจเจตนาระดับสูง (การเข้ารหัสที่ขับเคลื่อนด้วยพฤติกรรมและคล้ายไวยากรณ์) ซึ่งหมายความว่าผู้อ่านที่เป็นมนุษย์ก็สามารถทำได้เช่นกันหากอธิบายอย่างถูกต้อง หาก AI ไม่สามารถสรุปได้อย่างเหมาะสม มันก็จะบ่งชี้ถึงความจำเป็นในการอธิบายให้ง่ายขึ้น การทำงานร่วมกันกับ AI เน้นถึงประโยชน์เมตาดาต้าของโมเดลข้อมูลนี้ ซึ่งค่อนข้างคล้ายกับภาษาการเขียนโปรแกรมสำหรับข้อมูล (ภาษาเฉพาะโดเมนขนาดเล็กสำหรับธุรกรรม) การฝึกอบรม AI หรือสมาชิกในทีมก็เหมือนกับการสอนภาษาใหม่ให้พวกเขา เมื่อบรรลุความคล่องแคล่วแล้ว พลังในการแสดงออกก็มีความสำคัญ การตรวจสอบอย่างกระตือรือร้นของ AI ในบทสนทนาหนึ่งกล่าวถึง "ความสง่างามทางการรับรู้" ของโมเดล ซึ่งหมายความว่ามันสะท้อนได้ดีกับวิธีที่บุคคลหนึ่งอาจต้องการอธิบายเหตุการณ์โดยธรรมชาติ แม้ว่าจะอยู่ในรูปแบบที่บีบอัดก็ตาม ด้วยการปรับโครงสร้างของโมเดลให้สอดคล้องกับการเล่าเรื่องเชิงตรรกะของเหตุการณ์ แม้แต่ AI ซึ่งโดยพื้นฐานแล้วคือเครื่องจดจำรูปแบบ ก็พบว่ามันทำงานร่วมกันได้ สิ่งนี้เป็นลางดีสำหรับการบูรณาการ AI ในอนาคต ตัวอย่างเช่น ผู้ช่วยแชทบอทสามารถรับสตริงที่มีโครงสร้างเหล่านี้และตอบคำถามเกี่ยวกับสิ่งเหล่านั้นได้โดยเกิดความสับสนน้อยที่สุด หรือโมเดลการเรียนรู้ของเครื่องอาจใช้คุณสมบัติที่เข้ารหัส (บุคคล การกระทำ รหัส สล็อต) เพื่อตรวจจับรูปแบบหรือทำการคาดการณ์ (เช่น คาดการณ์ว่าลูกค้ามีแนวโน้มที่จะผิดนัดชำระหนี้ตามลำดับการกระทำของพวกเขา) โดยสรุป การกระตุ้นเตือนและการจัดตำแหน่ง AI เป็นทั้งเครื่องมือและเป้าหมายในกระบวนการพัฒนา พวกเขาช่วยกันกระสุนและรับรองว่าไม่ใช่แค่การออกแบบหอคอยงาช้าง แต่เป็นสิ่งที่ทดสอบกับความเข้าใจผิด ด้วยการพูดคุยกับ AI และบางครั้งก็ผลักดันให้มีการตอบรับที่ไม่ได้รับการแก้ไข ผู้สร้างโมเดลจึงปฏิบัติต่อ AI เหมือนกระดานที่ฟังดูตรงไปตรงมา ผลลัพธ์ที่ได้คือการออกแบบที่ไม่เพียงแต่ยืนหยัดต่อการตรวจสอบเชิงตรรกะเท่านั้น แต่ยังง่ายต่อการสื่อสารอีกด้วย ต้นฉบับนี้เป็นผลพลอยได้จากกระบวนการดังกล่าว โดยมีเป้าหมายที่จะยืนหยัดอยู่คนเดียวเพื่อเป็นคำอธิบายที่ชัดเจน เช่นเดียวกับบทสนทนาที่หล่อหลอมมัน บทสรุป: สู่ระบบข้อมูลที่ปรับเปลี่ยนได้และอธิบายตนเองได้ สิ่งที่เราสรุปไว้เป็นมากกว่าการปรับแต่งสคีมาฐานข้อมูล แต่เป็นการปรับโฉมวิธีการบันทึกและใช้งานข้อมูล โมเดลสตริงช่องการดำเนินการส่วนบุคคลแสดงให้เห็นว่ามีความเป็นไปได้ที่จะฝังสคีมาข้อมูลภายในตัวข้อมูลเอง ซึ่งทำให้เส้นแบ่งระหว่างข้อมูลและข้อมูลเมตาไม่ชัดเจน ด้วยการปฏิบัติต่อแต่ละบันทึกเสมือนเป็นการเล่าเรื่องในตัวเอง (พร้อมหัวเรื่อง การกระทำ และคำอธิบาย) เราได้ระบบที่ยืดหยุ่น แข็งแกร่ง และใช้งานง่ายสำหรับผู้ที่เข้าใจภาษานั้นในคราวเดียว แนวทางนี้นำธีมหลักบางส่วนมาไว้แถวหน้า: พฤติกรรมมากกว่าโครงสร้าง: เราจัดลำดับความสำคัญในการจับพฤติกรรม (เหตุการณ์การทำธุรกรรมในบริบทของมัน) มากกว่าการปฏิบัติตามโครงสร้างที่กำหนดไว้ล่วงหน้า โครงสร้างเกิดขึ้นจากความต้องการในการอธิบายพฤติกรรมอย่างครบถ้วน ในการทำเช่นนั้น เราได้นำหลักการนอร์มัลไลซ์แบบดั้งเดิมบางอย่างมาแลกกับความตรงและความเรียบง่ายในการใช้งานที่มากขึ้น และได้ผลดี: โมเดลข้อมูลของเราสามารถปรับตามพฤติกรรมที่เปลี่ยนไป โดยไม่ต้องปรับโครงสร้างตารางใหม่อย่างต่อเนื่อง การจัดตำแหน่งในโลกแห่งความเป็นจริง: โมเดลยอมรับว่ากระบวนการของมนุษย์และธุรกิจไม่ได้เรียบร้อยเสมอไป แทนที่จะบังคับให้กระบวนการที่ยุ่งเหยิงกลายเป็นตารางที่เรียบร้อย (แล้วจัดการกับผลกระทบด้วยการแก้ไขข้อผิดพลาดและภาคผนวก) กระบวนการจะรวบรวมความยุ่งเหยิงด้วยการเข้ารหัส ฟิลด์ตัวเลือก ความยาวผันแปรได้ หลายหมวดหมู่ในรายการเดียว ทั้งหมดนี้จัดการได้ เป็นระบบที่บอกว่า “บันทึกตามที่มันเกิดขึ้น ในทุกรายละเอียด” มั่นใจว่าจะสามารถถอดรหัสความแตกต่างนั้นได้ในภายหลัง การตีความที่เป็นสากล: ด้วยการไม่ผูกข้อมูลเข้ากับการตีความของแอปพลิเคชันใดแอปพลิเคชันหนึ่ง เราจึงอนุญาตให้เครื่องมือหรือบุคคลใดๆ โต้ตอบกับข้อมูลนั้นได้ มันชวนให้นึกถึงวิธีที่ CSV กลายเป็นภาษากลางสำหรับการแลกเปลี่ยนข้อมูลเนื่องจากความเรียบง่าย ที่นี่เรามี CSV ที่มีสมอง สามารถใช้งานได้ทันทีในสเปรดชีตหรือเป็นไฟล์บันทึก แต่ก็มีความลึกในการขับเคลื่อนระบบอัตโนมัติหรือการวิเคราะห์ AI เช่นกัน ความเป็นสากลนี้มีความสำคัญมากขึ้นเรื่อยๆ เมื่อระบบต่างๆ แพร่หลายมากขึ้น แหล่งความจริงเพียงแหล่งเดียวในรูปแบบที่เรียบง่ายนั้นมีคุณค่าอย่างยิ่ง การจัดการข้อมูลแบบลีน: ในทางปฏิบัติ การใช้โมเดลนี้สามารถนำไปสู่การดำเนินงานแบบลีนน้อยลง มีค่าใช้จ่ายน้อยลงในการบำรุงรักษาตารางฐานข้อมูลหลายรายการ งาน ETL น้อยลงในการรวมข้อมูล และโอกาสที่ข้อมูลจะไม่สอดคล้องกันระหว่างระบบน้อยลง บุคคลหนึ่งอธิบายว่าสิ่งนี้มี "สตริงเดียวในการควบคุมพวกเขาทั้งหมด" สำหรับแต่ละธุรกรรม ซึ่งหมายความว่าสตริงเดินทางจากอินพุตไปยังรายงานขั้นสุดท้ายโดยมีการเปลี่ยนแปลงเพียงเล็กน้อย ช่วยลดส่วนที่เคลื่อนไหวในการจัดการข้อมูล แน่นอนว่าแนวทางนี้ไม่ได้เกิดขึ้นโดยไม่มีความท้าทาย ต้องมีการออกแบบโค้ดและสล็อตเบื้องต้นอย่างระมัดระวัง (คล้ายกับการออกแบบไวยากรณ์ข้อมูล) มันต้องอาศัยวินัยในการใช้รูปแบบที่กำหนดไว้ต่อไป (แม้ว่าเราจะสามารถสร้างการตรวจสอบซอฟต์แวร์เพื่อบังคับใช้สิ่งนั้นได้) สมาชิกในทีมหรือระบบใหม่จะต้องเรียนรู้ “ภาษา” เพื่อใช้งานได้อย่างมีประสิทธิภาพ และจะมีกรณีขอบที่ทดสอบขีดจำกัดของระบบตำแหน่งคงที่อยู่เสมอ อย่างไรก็ตาม สิ่งที่สวยงามก็คือโมเดลนี้สามารถขยายได้: เราสามารถขยายภาษาได้ (เพิ่มโค้ดใหม่หรือความหมายของช่อง) ตราบใดที่เรายังคงความเข้ากันได้แบบย้อนหลัง มันคล้ายกับการเพิ่มคำศัพท์ใหม่ๆ ลงในคำศัพท์ของเราเมื่อเวลาผ่านไปเพื่ออธิบายปรากฏการณ์ใหม่ๆ ในการก้าวไปข้างหน้า เราสามารถทำให้โมเดลนี้กลายเป็นข้อกำหนดเฉพาะได้ ตัวอย่างเช่น การเขียนไวยากรณ์อย่างเป็นทางการ (ในรูปแบบ BNF) สำหรับรูปแบบสล็อตแอคชั่นบุคคล นั่นจะช่วยให้ตรวจสอบสตริงได้ง่ายขึ้น และอาจสร้างอินเทอร์เฟซผู้ใช้หรือเอกสารประกอบโดยอัตโนมัติด้วยซ้ำ นอกจากนี้ ไลบรารีโอเพ่นซอร์สสามารถช่วยแยกวิเคราะห์และสร้างสตริงเหล่านี้ เพื่อเร่งให้เกิดการยอมรับ ในด้านประสบการณ์ผู้ใช้ การพัฒนาอินเทอร์เฟซ (เช่น รูปแบบภาพหรือ “ตัวช่วยสร้างสตริงตรรกะ”) สามารถซ่อนความซับซ้อนจากผู้ใช้ปลายทางในขณะที่ใช้ประโยชน์จากโมเดลเบื้องหลัง ท้ายที่สุดแล้ว โมเดลข้อมูลที่ขับเคลื่อนด้วยพฤติกรรมนี้เป็นก้าวหนึ่งสู่ระบบข้อมูลที่สะท้อนเรื่องราวเชิงตรรกะของมนุษย์ แทนที่จะแยกส่วนโลกของเราออกเป็นตารางฐานข้อมูลแล้วประกอบกลับเป็นรายงาน เราจะรวบรวมโลกของเราให้มากที่สุดตั้งแต่เริ่มต้น ความหวังก็คือสิ่งนี้นำไปสู่ระบบที่ไม่เพียงแต่มีประสิทธิภาพ แต่ยังเข้าใจได้มากขึ้นอีกด้วย เมื่อผู้จัดการสามารถดูบันทึกและอ่านรายการ (แม้ว่าจะเข้ารหัสแล้วก็ตาม) และเข้าใจสิ่งที่เกิดขึ้น นั่นถือเป็นชัยชนะเพื่อความโปร่งใส เมื่อนักวิเคราะห์สามารถ pivot หรือสืบค้นข้อมูลโดยไม่จำเป็นต้องแยกเว็บตารางให้พันกัน นั่นคือข้อดีของความคล่องตัว และเมื่อสามารถนำ AI เข้าสู่วงจรและทำงานร่วมกันในการทำความเข้าใจข้อมูลได้โดยตรง มันก็บ่งบอกถึงอนาคตที่ระบบข้อมูลของเราสอดคล้องกับทั้งสัญชาตญาณของมนุษย์และความแม่นยำของเครื่องจักรอย่างแท้จริง โดยสรุป ด้วยการแทนที่สคีมาที่เข้มงวดด้วยเรกคอร์ดที่ฝังตรรกะและลื่นไหล เราจึงได้โมเดลข้อมูลที่เติบโตและเรียนรู้ไปพร้อมกับธุรกิจ ต้นฉบับนี้ได้นำเสนอแนวคิด เหตุผล และความหมายของระบบช่องบุคลิกภาพและการกระทำ โดยทำหน้าที่เป็นแนวทางอ้างอิงสำหรับผู้ที่อาจพิจารณานำโมเดลดังกล่าวไปใช้หรือปรับเปลี่ยนบางส่วน การเดินทางของการพัฒนาตอกย้ำบทเรียนสำคัญ: ถ้าเราเข้ารหัสความรู้ ณ จุดของการสร้างสรรค์ (ไม่ว่าจะเป็นข้อมูลหรือแนวคิด) เราจะใช้ความพยายามน้อยกว่ามากในการแก้ไขและตีความในภายหลัง ในขอบเขตของสถาปัตยกรรมข้อมูล นี่อาจเป็นเพียงการเปลี่ยนกระบวนทัศน์ไปสู่ระบบที่เรียบง่ายและชาญฉลาดยิ่งขึ้น ข้อมูลกำลังบอกเล่าเรื่องราวของตัวเอง เราแค่ต้องรับฟัง
 